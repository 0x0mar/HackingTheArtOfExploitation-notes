Hacking: the art of exploitation

live cd: setxkbmap es 
to set the keyboard layout to es in the console

file trasfer:
netcat!

mac:
	nc -l <port> > file

virtualmachine:
	nc <ip> <port> < file



0x200 Programming

0x242 arithmetic
	difference between a++ and ++a
	evaluate a then a = a+ 1 --> a++
	a = a+1 then evaluate a --> ++as


    C and booleans 
	C has no boolean type
	any nonzero value is true, a statement is false if it is 0
	explains shortcut of evaluate (expression == 1) --> (expression)
p30
    functions, function prototypes


	GCC compilation
	————————————————
		gcc firtsprog.c
		ls -l a.out


0x251 The Bigger Picture p 34 o p20
——————————————————————————

	gcc firstprog.c
	objdump -D a.out | grep -A20 main

	objdump -M intel -D a.out 
	for intel syntax

0x252 The x86 Processor
————————————————


gdb
====
	gdb -q ./a.out
	 break main
	 run
	 info registers
	 quit
      set dissassembly intel / set dis intel
		can set in the .gdbinit in the home directory
		echo "set dis intel" > ~/.gdbinit
		~s'escriu amb (alt dret + ñ)

	info register eip
		eax accumulator
		ecx counter
		edx data
		ebx base

		esp stack pointer
		ebp base pointer
		esi source index
		edi destination index

		eip instruction pointer
		EFLAGS comparisons and memory segmentation

	x/fmt address
		fmt: repeat count / format letter / size modifier
		format: o octal, x hex d decimal u unsigned decimal, t binary, f float, a address i instruction c char s string
		size letters: b byte, h halfword(16 bits, 2 byte), w word  ( word size here?? 4 byte , 32bit), g giant (8 bytes -> 64 bits)


	SOMETIMES CONFUSION:(in this book)
		DWORD, Giant -> 8 bytes
		WORD,  -> 4 BYTES ( i think in INtel syntax DWORD is 4, Word is 2)
		HALFWORD , SHORT -> 2 BYTES 

	sometimes word is 2 bytes, dword is 4 bytes and halfword = byte
	but sometimes word is 4 bytes…
	x/1iw main : push %ebp
	x/1xh main : 0x8955


	p43 (2	8)
		endianness, little endian
		





	p40  gcc -g include debugging info -> gdb with source code
	(gdb) list : shows source code

	disassemble main
	dump of assembler code for function main()

	break main
	run
	i r eip
	x/i $eip -> eip points to main + 16, before that there’s the function prologue



	info register tip
	i r eip
	x/x $eip  


	p43 (29)
	little-endian byte order, less significant byte stored first in x86 processors
	gdb reverses by itself -> show the mem “word” fetched in reverse order (so in its real meaning).
	x/4xb $eip 0xc7 0x45 0xfc 0x00
	x/1xw $eip 0x00fc45c7

	-> byte order in values ok
		but byte order in commands??? I think it is not reversed in that case

	command line calculator unix bc -ql
		199*(256^3) + 69*(256^2) + 252*(256^1) + 0*(256^0)

	more x “examine” commands
	——————————————————————
p44

	Storing in temporary variables
	(gdb) print $ebp - 4
	$1 = (void *) 0xbffff804
	(gdb) x/xw $1

		i r ebp
		x/4xb $ebp - 4
		x/4b 0xbffff804
		print $ebp - 4 //saves the result into temporary var $1
		x/4xb $1	 // uses previously saved var $1
		x/xw $1



	running commands
		start
		break main ;  run;
		nexti //next instruction  based on source code
		stepi // next instruction based on instructions in mem
		step ?
		c , cont, continue
		run //to run or to restart
		
		

p47

	man ascii -> ascii table on command line

	gdb c format letter
		x/14cb 0c8048484
			72 ‘H’ 101 ‘e’ …
	gdb s format leter
		x/s 0x8048484
			“Hello, world!\n”

	using print as a calculator
	print $ebp - 4
	x/x $1


	gdb bt to backtrace the stack

	gdb where command to backtrace the stack in a crash?


	breakpoints
	
	info break

	break *0x80485858

	delete breakpoint 8

	break *0x80488589
	printf “eax is %s\n”,$eax
	ends



p51 0x260 Back To Basics
—————————————————————————


	0x261 Strings
	………………………………..
	
	gcc -o char_array char_array.c
	
	null byte terminated strings
	strcpy() function from library string.h no loaded by default.

	gdb with gcc -g compiled program -> break strcpy() not resolved till execution
	breakpoint on strcpy() code
	call mechanism, stack


	gdb bt to backtrace the stack


	0x262 Signed, Unsigned, Long and Short
	———————————————————p55(41)

	signed	
	by default numerical values in C are signed
	negatives stored using two's complement:
		form suited for binary adders
		when a negative value in two's complement is added to a positive number of the same magnitude, the result will be 0 (with a carry bit)
		1-write the positive number in binary
		2-invert all the bits
		3-add 1

	pcalc example

	var declaration: by default in C int’s are signed
	unsigned
	unsigned int

	size of numerical variables
	adding short or long, depends on architecture
	sizeof() function (C macro in fact)

	int is  4bytes
	unsigned int is 4 bytes
	float is 4 bytes
	short int is  2bytes
	long int is 4 byes
	long long int is 8 bytes
	char is 1 byte

	0x263 Pointers
	———————p57 (43)
	in x86
		32-bit addressing,
		pointers 32-bit size (4 bytes)
		int *intpointer;
		pointer.c


	address of operator (&)
	dereference operator (*)


	gdb with
	pointer.c
	addresof.c
	p58


	pointer2.c

   printf("str_a=%d \n",(unsigned int)str_a);
   printf("*str_a=%d\n",(unsigned int)*str_a);
   printf("&str_a = %d\n",(unsigned int)&str_a);
   printf("&str_a[0]=%d\n",(unsigned int)&str_a[0]);
   printf("str_a[0]=%d\n",(unsigned int)str_a[0]);
   printf("*&str_a[0]=%d\n",(unsigned int)*&str_a[0]);
   printf("&str_a[1]=%d \n",(unsigned int)&str_a[1]);
   printf("str_a[1]=%d \n",(unsigned int)str_a[1]);
   printf("&str_a + 4=%d \n",(unsigned int)&str_a + 4);
   printf("(unsigned int)*(str_a + 0)=%d \n",(unsigned int)*(str_a + 0));
   printf("(unsigned int)*(str_a + 1)=%d \n",(unsigned int)*(str_a + 1 ));


 p59 observation: x/s pointer -> shows 0xbffff7e0: "Hello World!n" but the string is not located in 0xbffff7e0. Yes, actually, the string is located at 0xbffff7e0
		  x/xw pointer -> 0xbffff7e0 : 0x6c6c6548   0x6c6c6548 is the actual string, the values in char ascii numbers


 x/xw &pointer
 
p60 address_of.c

p61 address_of2.c

	Arrays in C paradox ??
		(revise that)
		char str_a[20]
		str_a[0] is like *str_a
		str_a[1] is like *(str_a + 1) //taking into account pointer arithmetic so if it’s a char pointer +1 means + 1 in memory, int pointer => + 1 means + 4 in memory
		str_a[] ??
		*str_a	  //? == str_a[0] ?
		str_a   // pointer, value of mem address of first element
		&str_a	  // address of the pointer

		PARADOX: char char_arr[20];
			   &char_arr == char_arr;   -> they show the same
			so char var1[X]; is like char *pointer;
			   so var1 = addres of first elem, and pointer = address of first elem
			   but &var1 = address of first elem!! whereas &pointer = addres of pointer

20140616———————————
	0x264 Format Strings
	---------------------

	format parameters : escape sequences with variable format and type specification
	
	these all expect values
	%d decimal
	%u unsigned
	%x hexadecimal
	%c char
		 
	these expect pointers
	%s string
	%n number of bytes written so far
	
	field with options
		%10d with of 10
		%010d with of 10 with leading 0's

	fmt_strings.c
	
	scanf() vars are pointer -> use pointers or unary operator address_of
	input.c

	0x265 Typecasting
	-----------------

	difference between c = a / b ; and d = (float) a / (float) b;


	pointer typecasting -> limiting errors
				  -> pointer arithmetic

	pointer arithmetic:

	%p == 0x%08x  in format strings
	pointer_types.c

	char_pointer ++ adds 1
	int_pointer ++ adds 4

	pointer_types2.c
	4-byte value 0x00000001 is stored as 0x01 0x00 0x00 0x00

	pointer_types3.c
	int_pointer = (int *) char_array;
	then when pointer arithmetic following the char array :	
	int_pointer = (int *) ((char *) int_pointer + 1); //to increment accordin to the char array pointer sizes

	typeless pointers
	void * point;
	cannot be dereferenced unless have a type
	cannot do pointer arithmetic unless have a type/cast->false???, means correct pointer arithmetic done with typecasting. whereas only byte arithmetic when void pointer.
	pointer_types4.c
	retrieve value *((char *) void_pointer)
	pointer arithmetic void_pointer = (void *) ((char *) void_pointer + 1)


	pointer_types5.c
	unsigned integer used as a void pointer
	unsigned int hacky_nonpointer;
	hacky_nonpointer = (unsigned int) char_array;
	value: *((char *)hacky_nonpointer)
	arithmetic: hacky_nonpointer = hacky_nonpointer + sizeof(char)


	variables of one type can be coerced into behaving like another type by telling the compiler


	p72 
	0x266 Command-Line arguments
	----------------------------

	integer and pointer to array of strings
	

	atoi()
	-----
	convert.c
	convert a pointer to a string to an integer

	segmentation fault if a program tries to access a segment of men he has not been given access to
	in this case given only 2 command line args and then accessing the third, value is 0 so program accesses memory at position 0 -> not allowed


	0x267 VariableScoping
	---------------------

	local variables
	scope.c

	global variables in C
	scope2.c
		->declare outside of the main() and other functions in the beginning
		->use without declaration inside the functions -> global var


	global and local vars -> memory address
	scope3.c
	put a breakpoint and bt
		memory addresses:

			-- text  segment --
			0x0804841d --> func2()
			0x0804849f --> func1()
			0x0804852b --> main()

			-- data? bss?  segment ---
			0x08049988 --> global var j (initialized so in data segment)

			-- stack segment --- grows towards 0
			0xbffff7c4 --> local i func2
			0xbffff7e4 --> local i func1
			0xbffff804 --> local i main


	gdb bt full --> shows local variables

	static variables
	static.c
	remain the same between calls, are initialized once, but have a scope/context like local vars
	static vars are local to a particular function context. are initialized only once

	static2.c



	0x270 Memory Segmentation
	======================== p 83

	text data bss heap stack

	text segment / code segment
		non linear  (branch, jump and call instructions)

		read only segment, non modifiable, shareable between different copies of the same code, fixed size

	data and bss segment
		global and static program variables
		data segment with global and static vars INITIALIZED
		bss segment with global and static vars UNINITIALIZED
		fixed size

	heap segment
		programmer can control, can allocate and free memory in this segment
		no fixed size, can grow
		managed by allocator and deallocator algorithms
		gowth moves toward higher memory addresses

	stack segment
		store local function variables and context during function calls
		passed variables, EIP return address, and local variables= stack frame

		abstract stack = FILO ordering, push and pop
		ESP register address of the end of the stack (lower address)
		stack grows toward lower memory addresses
		EBP : frame pointer or local base pointer, is used to reference 
		context , passed vars and local vars
		stack frame:
			local vars
			sep (saved frame pointer) old ebp, 
			return address,
			passed arguments to the call
		
	stack_example.c
		p 87-89


	0x271 Memory segments in C
	-------------------------- p 89

	memory_segments.c
	

	usage of malloc()
	returns a no type pointer must be typecasted

	p91
	0x272 Using the heap

	malloc() and free()
	men addresses of the vars allocated in the heap
		allocation + freeing + reallocation -> reusing men addresses depends on sizes…

	error checked malloc()

	use of function and function prototype

	0x280 building on Basics p 95
	========================


	0x281 File Access
	----------------- p 95

		File descriptors (basic low level I/O)
		File streams (high level buffered I/O)

		filedescriptor
			a file descriptor is a number that references an open file
			open(), read(), close(), write()
			return -1 on error

			open() returns file descriptor = integer value unique on the system
			file descriptor passed as a pointer to the file on the other functions (read, close, write)


		simplenote.c

		
			buffer and datafile declared not inicializaed -> bss segment
			then malloc to assign men space, buffer and datafile are char * pointers (string pointers)

			fcntl.h and sys/stat.h includes
			->define flags used on open()
				fcntl.h
					O_RDONLY, O_WRONLY, O_RDWR
					O_APPEND write data at the end
					O_TRUNC if file exists, truncate the file to the 0 length ?? borrar el contingut?
					O_CREAT
				sys/stat.h
					

		bitwise.c

		fcntl_flags.c
			p99


		0x282 File Permissions
		---------------------- p 100
		sys/stat.h

			S_I give
			S_IR give read permission
			S_IW give write permission
			S_IX give execute permission
			s_IRUSR give read permission to the user
			S_IWGRP give write permission to the group
			S_IXOTH give execute permission to others

			
		4 is read, 2 is write, 1 is execute
		can be added together because bitwise OR but 1's in different digit positions
		7=rwx
		6=rw
		5=rx
		4=r
		3=wx
		2=w
		1=x
		

		chmod 731 file
		chmod ugo-wx file "substract wx to u g and o"
		chmod u+x file "add x permission to u"

		0x283 User IDs
		---------------p102
		
		id to show the user ID on the system

		su: switch to different user
		sudo: single command to be run as root

		/tmp/notes with S_IRUSR | S_IWUSR -> so only readable and writable by owner
		other user can't use the program
			(provat amb user reader i despres jose , i tambe per primera vegada creat amb jose i despres accedit amb reader i mateix problema)


		setUID permission
		-----------------
			when a program with this flag is executed it runs as the user ID of the file's owner

			/usr/bin/chsh has the -rwxsr-xr-x  s is the setuid permission
			program will run as root, and any user can run it

			real user ID, effective user ID
			getuid() and geteuid()
			-> with setuid permission the effective uid (geteuid()) show's the program's owner uid,
			
		
		uid_demo.c

	
		hacking.h
			includes on c programs -> libraries
			#include <  >   //goes to standard locations on the system
			#include ""  //goes to . or location especific


		notesearch.c

			#DEFINE
			lseek(fd, length, SEEK_CUR)

			example of how chsh and passwd work on notesearch.c and notetaker.c

		0x284 Structs
		-------------p111

		ways to access struct elements
			name_struct_var.name_element
			name_struct_pointer->name_element
			*((int *) struct_pointer + pointer arithmetic)


		0x285 FUnction Pointers
		----------------------- p114
		
		int func_one() {
		...

		int main(){

			int (*function_ptr) ();
			function_ptr = func_one;
			value=function_ptr();

		0x286 Pseudorandom Generator
		----------------------------p115

		rand_example.c
			RAND_MAX
			srand(time(0))
			rand()%20 + 1

		0x287 A Game Of Chance
		----------------------

		
		probabilitat condicional
		3 cartes, 1 escollida: P(A)=1/3, P(0) = 1 - 1/3 = 2/3

		2 cartes, 1 escollida: P(A)=1/2, P(0)=1/2


		probabilitat condicional?

		P(B | A) prob de B condicionada a A

		P(A interseccio B) prob de A i B alhora

		P(B|A) = P(A interseccio B) / P(A)
		
		P(A) surti un 0 en primera tirada
		P(B) surti un as en segunda tirada

		P(A interseccio B)= surti un 0 primer i despres  un A?
				2/3 * 1/2

		P(A)= 2/3

		P(B|A) = 2/3 * 1/2 /2/3 = 1/2


		-------
		fem amb un espai de mostra de 4 cartes, un As , 3 0's
		P(A) = surti un 0 a la primera = 3/4
		P(B)= surti un A  a la segona = ??
		
		P(A interseccio B) = surti un 0 a la primera i un A a la segona=
				   = 3/4 * 1/3

		P(A) = 3/4

		--------
		4 CARTES, 2 A'S, 2 0'S
		P(A int B) = 1/2 * 2/3
		----
		sempre es el mateix, el punt es que
		al escollir primer hi ha un 1/3 de prob's
		al escollir la segona vegada hi ha un 1/2, 
			la pregunta es, sense escollir la segona vegada tambe tinc un 1/2?
		
		
		